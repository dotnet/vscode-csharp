{
  "command.csharp.attachToProcess": "Dołączanie do procesu platformy .NET 5 lub .NET Core",
  "command.csharp.downloadDebugger": "Pobierz debuger platformy .NET Core",
  "command.csharp.listProcess": "Wyświetl proces do dołączenia",
  "command.csharp.listRemoteDockerProcess": "Wyświetl listę procesów w połączeniu platformy Docker",
  "command.csharp.listRemoteProcess": "Wyświetl listę procesów w połączeniu zdalnym do dołączenia",
  "command.csharp.recordTrace": "Rejestrowanie śledzenia wydajności serwera języka C#",
  "command.csharp.reportIssue": "Zgłoś problem",
  "command.csharp.showDecompilationTerms": "Pokaż umowę warunków dekompilowania",
  "command.dotnet.generateAssets.currentProject": "Generuj zasoby na potrzeby kompilacji i debugowania",
  "command.dotnet.openSolution": "Otwórz rozwiązanie",
  "command.dotnet.restartServer": "Ponownie uruchom serwer języka",
  "command.dotnet.restore.all": "Przywróć wszystkie projekty",
  "command.dotnet.restore.project": "Przywróć projekt",
  "command.dotnet.test.debugTestsInContext": "Debuguj testy w kontekście",
  "command.dotnet.test.runTestsInContext": "Uruchom testy w kontekście",
  "command.extension.showRazorCSharpWindow": "Pokaż Razor CSharp",
  "command.extension.showRazorHtmlWindow": "Pokaż kod Html Razor",
  "command.o.fixAll.document": "Rozwiąż wszystkie wystąpienia problemu z kodem w dokumencie",
  "command.o.fixAll.project": "Rozwiąż wszystkie wystąpienia problemu z kodem w projekcie",
  "command.o.fixAll.solution": "Rozwiąż wszystkie wystąpienia problemu z kodem w rozwiązaniu",
  "command.o.pickProjectAndStart": "Wybierz projekt",
  "command.o.reanalyze.allProjects": "Analizuj wszystkie projekty",
  "command.o.reanalyze.currentProject": "Analizuj bieżący projekt",
  "command.o.restart": "Uruchom ponownie aplikację OmniSharp",
  "command.razor.reportIssue": "Zgłoś problem z aparatem Razor",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitObjectCreation": "Pokazuj wskazówki dotyczące niejawnego tworzenia obiektów",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitVariableTypes": "Pokaż wskazówki dla zmiennych z wnioskowanymi typami",
  "configuration.csharp.inlayHints.enableInlayHintsForIndexerParameters": "Pokaż wskazówki dla indeksatorów",
  "configuration.csharp.inlayHints.enableInlayHintsForLambdaParameterTypes": "Pokaż wskazówki dla typów parametrów funkcji lambda",
  "configuration.csharp.inlayHints.enableInlayHintsForTypes": "Wyświetl wskazówki w tekście dla typów",
  "configuration.dotnet.autoInsert.enableAutoInsert": "Włącz automatyczne wstawianie komentarzy do dokumentacji.",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope": "Uruchom analizę kodu w tle dla: (Wcześniej „omnisharp.enableRoslynAnalyzers”)",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.fullSolution": "Całe rozwiązanie",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.none": "Brak",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.openFiles": "Otwórz dokumenty",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope": "Pokaż błędy i ostrzeżenia kompilatora dla:",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.fullSolution": "Całe rozwiązanie",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.none": "Brak",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.openFiles": "Otwórz dokumenty",
  "configuration.dotnet.codeLens.enableReferencesCodeLens": "Określa, czy ma być wyświetlana funkcja CodeLens odwołań. (Wcześniej „csharp.referencesCodeLens.enabled”)",
  "configuration.dotnet.codeLens.enableTestsCodeLens": "Określa, czy ma być wyświetlana funkcja CodeLens testu przebiegu i debugowania. (Wcześniej „csharp.testsCodeLens.enabled”)",
  "configuration.dotnet.completion.provideRegexCompletions": "Pokaż wyrażenia regularne na liście uzupełniania.",
  "configuration.dotnet.completion.showCompletionItemsFromUnimportedNamespaces": "Zapewnia obsługę wyświetlania niezaimportowanych typów i niezaimportowanych metod rozszerzeń na listach uzupełniania. Po zadeklarowaniu odpowiednia dyrektywa using zostanie dodana w górnej części bieżącego pliku. (Wcześniej „omnisharp.enableImportCompletion”)",
  "configuration.dotnet.completion.showNameCompletionSuggestions": "Wykonaj automatyczne uzupełnianie nazw obiektów dla elementów członkowskich, które zostały ostatnio wybrane.",
  "configuration.dotnet.completion.triggerCompletionInArgumentLists": "Automatycznie pokaż listę uzupełniania na listach argumentów",
  "configuration.dotnet.defaultSolution.description": "Ścieżka domyślnego rozwiązania, która ma zostać otwarta w obszarze roboczym, lub ustawiona na wartość „wyłącz”, aby je pominąć. (Poprzednio „omnisharp.defaultLaunchSolution”)",
  "configuration.dotnet.diagnostics.reportInformationAsHint": "Włącz to ustawienie, aby ograniczyć wizualne elementy rozpraszające uwagę w edytorze. Problemy z informacjami będą zgłaszane jako wskazówki i będą widoczne tylko wtedy, gdy jest otwarte wyskakujące okno akcji kodu.",
  "configuration.dotnet.enableXamlTools": "Włącza narzędzia XAML podczas korzystania z zestawu deweloperskiego języka C#",
  "configuration.dotnet.formatting.organizeImportsOnFormat": "Określa, czy dyrektywy „using” mają być grupowane i sortowane podczas formatowania dokumentu. (Poprzednio „omnisharp.organizeImportsOnFormat”)",
  "configuration.dotnet.highlighting.highlightRelatedJsonComponents": "Wyróżnij powiązane składniki JSON pod kursorem.",
  "configuration.dotnet.highlighting.highlightRelatedRegexComponents": "Wyróżnij powiązane składniki wyrażenia regularnego pod kursorem.",
  "configuration.dotnet.inlayHints.enableInlayHintsForLiteralParameters": "Pokaż wskazówki dla literałów",
  "configuration.dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": "Pokaż wskazówki dla wyrażeń „new”",
  "configuration.dotnet.inlayHints.enableInlayHintsForOtherParameters": "Pokaż wskazówki dla wszystkich innych elementów",
  "configuration.dotnet.inlayHints.enableInlayHintsForParameters": "Wyświetl wskazówki dotyczące nazwy parametru wbudowanego",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatDifferOnlyBySuffix": "Pomiń wskazówki, gdy nazwy parametrów różnią się tylko sufiksem",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchArgumentName": "Pomiń wskazówki, gdy argument pasuje do nazwy parametru",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchMethodIntent": "Pomiń wskazówki, gdy nazwa parametru pasuje do intencji metody",
  "configuration.dotnet.navigation.navigateToDecompiledSources": "Włącz nawigację do zdekompilowanych źródeł.",
  "configuration.dotnet.navigation.navigateToSourceLinkAndEmbeddedSources": "Włącz nawigację do linku do źródła i osadzonych źródeł.",
  "configuration.dotnet.preferCSharpExtension": "Wymusza ładowanie projektów tylko z rozszerzeniem języka C#.  Może to być przydatne w przypadku korzystania ze starszych typów projektów, które nie są obsługiwane przez zestaw C# Dev Kit. (Wymaga ponownego załadowania okna)",
  "configuration.dotnet.projects.binaryLogPath": "Ustawia ścieżkę, w której dzienniki binarne programu MSBuild są zapisywane podczas ładowania projektów, aby ułatwić diagnozowanie błędów ładowania.",
  "configuration.dotnet.projects.enableAutomaticRestore": "Włącza automatyczne przywracanie pakietu NuGet, jeśli rozszerzenie wykryje brak zasobów.",
  "configuration.dotnet.projects.enableFileBasedPrograms": "Włącza podgląd środowiska „programy oparte na plikach” (dotnet run app.cs).",
  "configuration.dotnet.quickInfo.showRemarksInQuickInfo": "Pokaż informacje o uwagach podczas wyświetlania symbolu.",
  "configuration.dotnet.server.componentPaths": "Umożliwia zastąpienie ścieżki folderu dla wbudowanych składników serwera języka (na przykład przesłonięcie ścieżki roslynDevKit w katalogu rozszerzenia w celu użycia składników skompilowanych lokalnie)",
  "configuration.dotnet.server.componentPaths.roslynDevKit": "Przesłania ścieżkę folderu dla składnika roslynDevKit serwera językowego",
  "configuration.dotnet.server.componentPaths.xamlTools": "Zastępuje ścieżkę folderu dla składnika xamlTools serwera języka",
  "configuration.dotnet.server.crashDumpPath": "Ustawia ścieżkę folderu, w której są zapisywane zrzuty awaryjne w przypadku awarii serwera języka.  Użytkownik musi mieć możliwość zapisu.",
  "configuration.dotnet.server.extensionPaths": "Przesłoń ścieżkę do serwera językowego --argumenty rozszerzenia",
  "configuration.dotnet.server.path": "Określa ścieżkę bezwzględną do pliku wykonywalnego serwera (LSP lub O#). W przypadku pozostawienia tej wartości pustej, używana jest wersja przypięta do rozszerzenia języka C#. (Wcześniej „omnisharp.path”)",
  "configuration.dotnet.server.startTimeout": "Określa limit czasu (w ms) dla pomyślnego uruchomienia klienta i nawiązania połączenia z serwerem języka.",
  "configuration.dotnet.server.suppressLspErrorToasts": "Pomija wyświetlanie wyskakujących powiadomień o błędach, jeśli serwer napotka błąd do odzyskania.",
  "configuration.dotnet.server.suppressMiscellaneousFilesToasts": "Pomiń wyświetlanie wyskakujących powiadomień ostrzegawczych, jeśli dokument aktywny znajduje się poza otwartym obszarem roboczym.",
  "configuration.dotnet.server.useServerGC": "Skonfiguruj serwer językowy do używania funkcji odzyskiwania pamięci serwera .NET.  Odzyskiwanie pamięci serwera zasadniczo zapewnia lepszą wydajność przy wyższym zużyciu pamięci.",
  "configuration.dotnet.server.waitForDebugger": "Przekazuje flagę --debug podczas uruchamiania serwera, aby umożliwić dołączenie debugera. (Wcześniej „omnisharp.waitForDebugger”)",
  "configuration.dotnet.symbolSearch.searchReferenceAssemblies": "Wyszukaj symbole w zestawach odwołań. Ma to wpływ na funkcje wymagające wyszukiwania symboli, takie jak dodawanie importów.",
  "configuration.dotnet.typeMembers.memberInsertionLocation": "Lokalizacja wstawiania właściwości, zdarzeń i metod podczas implementowania interfejsu lub klasy abstrakcyjnej.",
  "configuration.dotnet.typeMembers.memberInsertionLocation.atTheEnd": "Umieść je na końcu.",
  "configuration.dotnet.typeMembers.memberInsertionLocation.withOtherMembersOfTheSameKind": "Umieść je z innymi elementami członkowskimi tego samego rodzaju.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior": "Zachowanie generowania właściwości podczas implementowania interfejsu lub klasy abstrakcyjnej.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior.preferAutoProperties": "Preferuj właściwości automatyczne.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior.preferThrowingProperties": "Preferuj właściwości przerzucane.",
  "configuration.dotnet.unitTestDebuggingOptions": "Opcje używane z debugerem podczas uruchamiania na potrzeby debugowania testów jednostkowych. (Wcześniej „csharp.unitTestDebuggingOptions”)",
  "configuration.dotnet.unitTests.runSettingsPath": "Ścieżka do pliku .runsettings, który powinien być używany podczas uruchamiania testów jednostkowych. (Poprzednio „omnisharp.testRunSettings”)",
  "configuration.omnisharp.autoStart": "Określa, czy serwer OmniSharp zostanie uruchomiony automatycznie. W przypadku wartości false element OmniSharp można uruchomić za pomocą polecenia „Restart OmniSharp”",
  "configuration.omnisharp.csharp.format.enable": "Włącz/wyłącz domyślny program formatujący języka C# (wymaga ponownego uruchomienia).",
  "configuration.omnisharp.csharp.maxProjectFileCountForDiagnosticAnalysis": "Określa maksymalną liczbę plików, dla których diagnostyka jest raportowana dla całego obszaru roboczego. Jeśli ten limit zostanie przekroczony, diagnostyka będzie wyświetlana tylko dla aktualnie otwartych plików. Określ wartość 0 lub mniejszą, aby całkowicie wyłączyć limit.",
  "configuration.omnisharp.csharp.referencesCodeLens.filteredSymbols": "Tablica niestandardowych nazw symboli, dla których należy wyłączyć funkcję CodeLens.",
  "configuration.omnisharp.csharp.semanticHighlighting.enabled": "Włącz/wyłącz wyróżnianie semantyczne dla plików języka C# (pliki Razor nie są obecnie obsługiwane). Wartość domyślna to false. Zamknij otwarte pliki, aby zmiany zostały wprowadzone.",
  "configuration.omnisharp.csharp.showOmnisharpLogOnError": "Pokazuje dziennik OmniSharp w okienku Dane wyjściowe, gdy dziennik OmniSharp zgłasza błąd.",
  "configuration.omnisharp.csharp.suppressBuildAssetsNotification": "Pomiń okno powiadomień, aby dodać brakujące zasoby do kompilacji lub debugowania aplikacji.",
  "configuration.omnisharp.csharp.suppressDotnetInstallWarning": "Pomiń ostrzeżenie, że zestaw .NET Core SDK nie znajduje się w ścieżce.",
  "configuration.omnisharp.csharp.suppressDotnetRestoreNotification": "Pomiń okno powiadomień, aby wykonać polecenie „dotnet restore”, gdy nie można rozwiązać zależności.",
  "configuration.omnisharp.csharp.suppressHiddenDiagnostics": "Pomiń diagnostykę „hidden” (taką jak „niepotrzebne dyrektywy using”) w celu uniemożliwienia wyświetlania w edytorze lub w okienku Problemy.",
  "configuration.omnisharp.csharp.suppressProjectJsonWarning": "Pomiń ostrzeżenie, że project.json nie jest już obsługiwanym formatem projektu dla aplikacji platformy .NET Core",
  "configuration.omnisharp.disableMSBuildDiagnosticWarning": "Określa, czy powiadomienia powinny być wyświetlane, jeśli element OmniSharp napotka ostrzeżenia lub błędy podczas ładowania projektu. Pamiętaj, że te ostrzeżenia/błędy są zawsze emitowane do dziennika OmniSharp",
  "configuration.omnisharp.dotNetCliPaths": "Ścieżki do lokalnego pobierania interfejsu wiersza polecenia platformy .NET do użycia na potrzeby uruchamiania dowolnego kodu użytkownika.",
  "configuration.omnisharp.dotnet.server.useOmnisharp": "Przełącza do używania serwera Omnisharp na potrzeby funkcji językowych, gdy ta opcja jest włączona (wymaga ponownego uruchomienia). Ta opcja nie będzie honorowana przy zainstalowanym zestawie Dev Kit języka C#.",
  "configuration.omnisharp.dotnetPath": "Określa ścieżkę do katalogu instalacyjnego dotnet, który ma być używany zamiast domyślnego katalogu systemowego. Ma to wpływ tylko na instalację platformy dotnet używaną do hostowania samego serwera OmniSharp. Przykład: „/home/username/mycustomdotnetdirectory”.",
  "configuration.omnisharp.enableAsyncCompletion": "Umożliwia asynchroniczne rozpoznawanie edycji uzupełniania. Może to przyspieszyć wyświetlanie listy uzupełniania, w szczególności list przesłonięć i częściowej listy uzupełniania metod, kosztem nieznacznych opóźnień po wstawieniu elementu uzupełniania. Większość elementów uzupełniania nie będzie mieć widocznego wpływu na tę funkcję, ale wpisanie tekstu bezpośrednio po wstawieniu przesłonięcia lub częściowego ukończenia metody przed ukończeniem wstawiania może dawać nieprzewidywalne wyniki.",
  "configuration.omnisharp.enableDecompilationSupport": "Umożliwia obsługę dekompilowania odwołań zewnętrznych zamiast wyświetlania metadanych.",
  "configuration.omnisharp.enableEditorConfigSupport": "Włącza obsługę odczytywania stylu kodu, konwencji nazewnictwa i ustawień analizatora z pliku .editorconfig.",
  "configuration.omnisharp.enableLspDriver": "Włącza obsługę eksperymentalnego aparatu opartego na protokole językowym (wymaga ponownego załadowania w celu poprawnego skonfigurowania powiązań)",
  "configuration.omnisharp.enableMsBuildLoadProjectsOnDemand": "Jeśli wartość jest równa true, system projektów programu MSBuild będzie ładować tylko projekty dla plików otwartych w edytorze. To ustawienie jest przydatne w przypadku dużych baz kodów języka C# i umożliwia szybsze inicjowanie funkcji nawigowania po kodzie tylko dla projektów istotnych dla edytowanego kodu. Jeśli to ustawienie jest włączone, element OmniSharp może ładować mniej projektów i dlatego może wyświetlać niekompletne listy odwołań dla symboli.",
  "configuration.omnisharp.loggingLevel": "Określa poziom danych wyjściowych rejestrowania z serwera OmniSharp.",
  "configuration.omnisharp.maxFindSymbolsItems": "Maksymalna liczba elementów, które mogą być wyświetlane przez operację „Przejdź do symbolu w obszarze roboczym”. Limit jest stosowany tylko wtedy, gdy w tym miejscu określono liczbę dodatnią.",
  "configuration.omnisharp.maxProjectResults": "Maksymalna liczba projektów do pokazania na liście rozwijanej „Wybierz projekt” (maksymalnie 250).",
  "configuration.omnisharp.minFindSymbolsFilterLength": "Minimalna liczba znaków do wprowadzenia przed wykonaniem operacji „Przejdź do symbolu w obszarze roboczym” powoduje wyświetlenie wyników.",
  "configuration.omnisharp.monoPath": "Określa ścieżkę do instalacji mono, która ma być używana, gdy element „useModernNet” jest ustawiony na wartość false, a nie domyślną instalację systemową. Przykład: \"„/Library/Frameworks/Mono.framework/Versions/Current”",
  "configuration.omnisharp.projectFilesExcludePattern": "Wzorzec wykluczania używany przez element OmniSharp do znajdowania wszystkich plików projektu.",
  "configuration.omnisharp.projectLoadTimeout": "Czas, przez który edytor Visual Studio Code będzie oczekiwać na uruchomienie serwera OmniSharp. Czas jest wyrażony w sekundach.",
  "configuration.omnisharp.razor.completion.commitElementsWithSpace": "Określa, czy zatwierdzać pomocnik tagów i elementy składników ze spacjami.",
  "configuration.omnisharp.razor.devmode": "Wymusza uruchomienie rozszerzenia w trybie umożliwiającym lokalne programowanie Razor.VSCode.",
  "configuration.omnisharp.razor.format.codeBlockBraceOnNextLine": "Wymusza, aby otwierający nawias klamrowy po dyrektywie @code lub @functions był w następującym wierszu.",
  "configuration.omnisharp.razor.format.enable": "Włącz/wyłącz domyślny moduł formatowania Razor.",
  "configuration.omnisharp.razor.plugin.path": "Przesłania ścieżkę do biblioteki dll wtyczki Razor.",
  "configuration.omnisharp.sdkIncludePrereleases": "Określa, czy dołączać wersje zapoznawcze zestawu .NET SDK podczas określania wersji, która ma być używana do ładowania projektu. Ma zastosowanie, gdy właściwość „useModernNet” jest ustawiona na wartość true.",
  "configuration.omnisharp.sdkPath": "Określa ścieżkę do instalacji zestawu .NET SDK, która ma być używana do ładowania projektu zamiast zainstalowanej najwyższej wersji. Ma zastosowanie, gdy właściwość „useModernNet” jest ustawiona na wartość true. Przykład: /home/username/dotnet/sdks/6.0.300.",
  "configuration.omnisharp.sdkVersion": "Określa wersję zestawu .NET SDK, która ma być używana do ładowania projektu zamiast zainstalowanej najwyższej wersji. Ma zastosowanie, gdy właściwość „useModernNet” jest ustawiona na wartość true. Przykład: 6.0.300.",
  "configuration.omnisharp.useEditorFormattingSettings": "Określa, czy element OmniSharp powinien używać ustawień edytora VS Code dla formatowania kodu języka C# (używać kart, rozmiaru wcięć).",
  "configuration.omnisharp.useModernNet.description": "Użyj kompilacji OmniSharp dla platformy .NET 6. Ta wersja _nie_ obsługuje projektów .NET Framework innych niż SDK, w tym aparat Unity. Projekty platformy w stylu zestawu SDK, platformy .NET Core i platformy .NET 5+ powinny widzieć znaczącą poprawę wydajności.",
  "configuration.omnisharp.useModernNet.title": "Użyj kompilacji .NET 6 elementu OmniSharp",
  "configuration.razor.languageServer.cohostingEnabled": "Włącz współhosting Razor.",
  "configuration.razor.languageServer.debug": "Określa, czy czekać na dołączenie debugowania podczas uruchamiania serwera języka.",
  "configuration.razor.languageServer.directory": "Przesłania ścieżkę do katalogu serwera języka Razor.",
  "configuration.razor.languageServer.forceRuntimeCodeGeneration": "Włącz łączny czas projektowania/generowania kodu środowiska uruchomieniowego dla plików Razor",
  "configuration.razor.languageServer.suppressLspErrorToasts": "Pomija wyświetlanie wyskakujących powiadomień o błędach, jeśli serwer napotka błąd do odzyskania.",
  "configuration.razor.languageServer.useNewFormattingEngine": "Użyj nowego aparatu formatowania Razor.",
  "configuration.razor.server.trace": "Określa poziom rejestrowania, który ma być używany dla serwera Razor.",
  "debuggers.coreclr.configurationSnippets.description.attach": "Dołącz debuger platformy .NET (coreclr) do uruchomionego procesu. Można to również zrobić za pomocą polecenia „Dołącz do procesu .NET 5+ lub .NET Core”.",
  "debuggers.coreclr.configurationSnippets.description.blazor-hosted": "Ten fragment kodu służy do uruchamiania nowego procesu w debugerze zestawu WebAssembly platformy Blazor (blazorwasm), określając ścieżkę do pliku wykonywalnego do uruchomienia. W większości przypadków „.NET: Fragment kodu „Launch C# project” (Uruchom projekt C#) jest lepszym wyborem, ale za pomocą tego fragmentu kodu można mieć pełną kontrolę nad wszystkimi opcjami uruchamiania. Ten fragment kodu jest przeznaczony dla hostowanych projektów Platformy Blazor, czyli projektu, który ma zaplecze ASP.NET aplikacji Core do obsługi plików.",
  "debuggers.coreclr.configurationSnippets.description.blazor-standalone": "Ten fragment kodu służy do uruchamiania nowego procesu w debugerze zestawu WebAssembly platformy Blazor (blazorwasm). W większości przypadków „.NET: Fragment kodu „Launch C# project” (Uruchom projekt C#) jest lepszym wyborem, ale za pomocą tego fragmentu kodu można mieć pełną kontrolę nad wszystkimi opcjami uruchamiania. Ten fragment kodu jest przeznaczony dla autonomicznych projektów Platformy Blazor, będących projektem, który nie ma aplikacji zaplecza ASP.NET Core do obsługi plików.",
  "debuggers.coreclr.configurationSnippets.description.console-local": "Ten fragment kodu służy do uruchamiania nowego procesu w debugerze .NET (coreclr), określając ścieżkę do pliku wykonywalnego do uruchomienia. W większości przypadków „.NET: Fragment kodu „Launch C# project” (Uruchom projekt C#) jest lepszym wyborem. Ten fragment kodu jest przydatny, gdy projekt został skompilowany poza tym wystąpieniem programu VS Code lub chcesz hostować kod .NET w niestandardowym pliku wykonywalnym, takim jak określona wersja pliku „dotnet.exe”/„dotnet” lub program .NET Code jest hostowany przez aplikację natywną. Ten fragment kodu jest przeznaczony dla aplikacji konsolowych.",
  "debuggers.coreclr.configurationSnippets.description.remote": "Ten fragment kodu pokazuje, jak zdalnie debugować kod .NET **bez** przy użyciu komunikacji zdalnej programu VS Code. Powinien być używany w przypadkach, gdy chcesz skompilować projekt lokalnie, ale chcesz uruchomić go na innym komputerze.",
  "debuggers.coreclr.configurationSnippets.description.web-local": "Ten fragment kodu służy do uruchamiania nowego procesu w debugerze .NET (coreclr), określając ścieżkę do pliku wykonywalnego do uruchomienia. W większości przypadków „.NET: Fragment kodu „Launch C# project” (Uruchom projekt C#) jest lepszym wyborem. Ten fragment kodu jest przydatny, gdy projekt został skompilowany poza tym wystąpieniem programu VS Code lub chcesz hostować kod .NET w niestandardowym pliku wykonywalnym, takim jak określona wersja pliku „dotnet.exe”/„dotnet” lub program .NET Code jest hostowany przez aplikację natywną. Ten fragment kodu jest przeznaczony dla aplikacji internetowych (ASP.NET Core).",
  "debuggers.coreclr.configurationSnippets.label.attach-local": ".NET: Dołącz do procesu platformy .NET",
  "debuggers.coreclr.configurationSnippets.label.attach-remote": ".NET: Zdalne debugowanie — dołącz do procesu platformy .NET",
  "debuggers.coreclr.configurationSnippets.label.blazor-hosted": ".NET: Zestaw sieci Web — uruchom hostowany projekt Platformy Blazor",
  "debuggers.coreclr.configurationSnippets.label.blazor-standalone": ".NET: Zestaw sieci Web — uruchom autonomiczny projekt Platformy Blazor",
  "debuggers.coreclr.configurationSnippets.label.console-local": ".NET: Uruchom plik wykonywalny (konsola)",
  "debuggers.coreclr.configurationSnippets.label.console-remote": ".NET: Zdalne debugowanie — uruchamianie pliku wykonywalnego (konsola)",
  "debuggers.coreclr.configurationSnippets.label.web-local": ".NET: Uruchom plik wykonywalny (sieć Web)",
  "debuggers.dotnet.configurationSnippets.description": "Ten fragment kodu konfiguruje program VS Code do debugowania projektu języka C#. Opcje debugowania (przykład: argumenty pliku wykonywalnego) można skonfigurować za pomocą pliku „<project-directory>/Properties/launchSettings.json”.",
  "debuggers.dotnet.configurationSnippets.label": ".NET: Uruchom projekt języka C#",
  "debuggers.dotnet.launch.launchConfigurationId.description": "Identyfikator konfiguracji uruchamiania do użycia. Pusty ciąg znaków spowoduje użycie bieżącej aktywnej konfiguracji.",
  "debuggers.dotnet.launch.projectPath.description": "Ścieżka do pliku .csproj.",
  "generateOptionsSchema.args.0.description": "Argumenty wiersza polecenia przekazywane do programu.",
  "generateOptionsSchema.args.1.description": "Wersja konwertowana na ciąg argumentów wiersza polecenia przekazanych do programu.",
  "generateOptionsSchema.checkForDevCert.description": "Jeśli uruchamiasz projekt sieci Web w systemie Windows lub macOS i jest on włączony, debuger sprawdzi, czy komputer ma certyfikat HTTPS z podpisem własnym używany do tworzenia serwerów internetowych działających w punktach końcowych HTTPS. Jeśli nie zostanie określona, wartością domyślną będzie true, gdy ustawiona jest wartość„serverReadyAction”. Ta opcja nie pełni żadnej funkcji w scenariuszach interfejsu użytkownika systemu Linux, zdalnego VS Code i VS Code w sieci Web. Jeśli certyfikat HTTPS nie zostanie znaleziony lub nie będzie zaufany, użytkownik zostanie poproszony o zainstalowanie lub zaufanie.",
  "generateOptionsSchema.console.externalTerminal.enumDescription": "Proces docelowy zostanie uruchomiony wewnątrz własnego terminalu zewnętrznego. W przypadku korzystania z tego trybu należy przełączyć fokus między edytorem Visual Studio Code a zewnętrznym oknem terminalu.",
  "generateOptionsSchema.console.integratedTerminal.enumDescription": "Proces docelowy zostanie uruchomiony wewnątrz zintegrowanego terminalu edytora VS Code.",
  "generateOptionsSchema.console.internalConsole.enumDescription": "Dane wejściowe (stdin) i dane wyjściowe (stdout/stderr) procesu docelowego są kierowane przez konsolę debugowania edytora VS Code.",
  "generateOptionsSchema.console.markdownDescription": "Wskazuje konsolę, do której ma zostać uruchomiony program docelowy. Aby uzyskać więcej informacji, zobacz https://aka.ms/VSCode-CS-LaunchJson-Console.",
  "generateOptionsSchema.console.settingsDescription": "**Uwaga:** _Ta opcja jest używana tylko w przypadku projektów konsoli uruchamianych z typem konfiguracji debugowania „dotnet”_.\r\n\r\nWskazuje konsolę, do której ma zostać uruchomiony program docelowy. Aby uzyskać więcej informacji, zobacz https://aka.ms/VSCode-CS-LaunchJson-Console.",
  "generateOptionsSchema.cwd.description": "Ścieżka do katalogu roboczego debugowanego programu. Ustawieniem domyślnym jest bieżący obszar roboczy.",
  "generateOptionsSchema.debugServer.description": "Tylko dla programowania rozszerzeń debugowania: jeśli określono port, program VS Code próbuje nawiązać połączenie z adapterem debugowania uruchomionym w trybie serwera",
  "generateOptionsSchema.enableStepFiltering.markdownDescription": "Flaga umożliwiająca przejście przez właściwości i operatory. Ta opcja jest domyślnie ustawiona na wartość „true”.",
  "generateOptionsSchema.env.description": "Zmienne środowiskowe przekazywane do programu.",
  "generateOptionsSchema.envFile.markdownDescription": "Zmienne środowiskowe przekazywane do programu przez plik, np. „${workspaceFolder}/.env”",
  "generateOptionsSchema.expressionEvaluationOptions.allowFastEvaluate.description": "W przypadku wartości true (stan domyślny) debuger podejmie próbę szybszego obliczania, symulując wykonywanie prostych właściwości i metod.",
  "generateOptionsSchema.expressionEvaluationOptions.allowImplicitFuncEval.description": "W przypadku wartości true (stan domyślny) debuger automatycznie wywoła metody „pobierz” właściwości i inne niejawne wywołania funkcji.",
  "generateOptionsSchema.expressionEvaluationOptions.allowToString.markdownDescription": "W przypadku wartości true (stan domyślny) debuger automatycznie wywoła metodę „DoCiągu” w celu sformatowania obiektów. Ta opcja nie ma żadnego efektu, jeśli właściwość „allowImplicitFuncEval” ma wartość „false”.",
  "generateOptionsSchema.expressionEvaluationOptions.description": "Opcje umożliwiające kontrolowanie sposobu oceniania wyrażeń przez debugera w poradach dotyczących danych, sekcjach „Wyrażenie kontrolne” i „Zmienne” widoku debugowania lub w konsoli debugowania.",
  "generateOptionsSchema.expressionEvaluationOptions.showRawValues.description": "W przypadku wartości true debuger wyświetli nieprzetworzoną strukturę obiektów w oknach zmiennych.",
  "generateOptionsSchema.externalConsole.markdownDescription": "Atrybut „externalConsole” jest przestarzały. Użyj zamiast niego atrybutu „console”. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.justMyCode.markdownDescription": "Gdy ta opcja jest włączona (wartość domyślna), debuger wyświetla tylko kod użytkownika dotyczący informacji o krokach („Mój kod”), ignorując kod systemowy i inny zoptymalizowany kod lub który nie ma symboli debugowania. [Więcej informacji](https://aka.ms/VSCode-CS-LaunchJson-JustMyCode)",
  "generateOptionsSchema.launchBrowser.args.description": "Argumenty do przekazania do polecenia w celu otwarcia przeglądarki. Jest to używane tylko wtedy, gdy element specyficzny dla platformy („osx”, „linux” lub „windows”) nie określa wartości dla elementu „args”. Użyj *polecenia ${auto-detect-url}, aby automatycznie używać adresu, na którym nasłuchuje serwer.",
  "generateOptionsSchema.launchBrowser.description": "Opisuje opcje służące do uruchamiania przeglądarki internetowej w ramach uruchamiania",
  "generateOptionsSchema.launchBrowser.enabled.description": "Określa, czy jest włączone uruchamianie przeglądarki internetowej. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.launchBrowser.linux.args.description": "Argumenty do przekazania do polecenia w celu otwarcia przeglądarki. Użyj polecenia ${auto-detect-url}, aby automatycznie używać adresu, na którym nasłuchuje serwer.",
  "generateOptionsSchema.launchBrowser.linux.command.description": "Plik wykonywalny, który uruchomi przeglądarkę internetową.",
  "generateOptionsSchema.launchBrowser.linux.description": "Opcje konfiguracji uruchamiania sieci Web specyficzne dla systemu Linux. Domyślnie spowoduje to uruchomienie przeglądarki przy użyciu polecenia „xdg-open”.",
  "generateOptionsSchema.launchBrowser.osx.args.description": "Argumenty do przekazania do polecenia w celu otwarcia przeglądarki. Użyj polecenia ${auto-detect-url}, aby automatycznie używać adresu, na którym nasłuchuje serwer.",
  "generateOptionsSchema.launchBrowser.osx.command.description": "Plik wykonywalny, który uruchomi przeglądarkę internetową.",
  "generateOptionsSchema.launchBrowser.osx.description": "Opcje konfiguracji uruchamiania sieci Web specyficzne dla systemu OSX. Domyślnie spowoduje to uruchomienie przeglądarki przy użyciu polecenia „open”.",
  "generateOptionsSchema.launchBrowser.windows.args.description": "Argumenty do przekazania do polecenia w celu otwarcia przeglądarki. Użyj polecenia ${auto-detect-url}, aby automatycznie używać adresu, na którym nasłuchuje serwer.",
  "generateOptionsSchema.launchBrowser.windows.command.description": "Plik wykonywalny, który uruchomi przeglądarkę internetową.",
  "generateOptionsSchema.launchBrowser.windows.description": "Opcje konfiguracji uruchamiania sieci Web specyficzne dla systemu Windows. Domyślnie spowoduje to uruchomienie przeglądarki przy użyciu polecenia „cmd /c start”.",
  "generateOptionsSchema.launchSettingsFilePath.markdownDescription": "Ścieżka do pliku launchSettings.json. Jeśli ta opcja nie zostanie ustawiona, debuger będzie wyszukiwać w pliku „{cwd}/Properties/launchSettings.json”.",
  "generateOptionsSchema.launchSettingsProfile.description": "Jeśli ta wartość jest określona, wskazuje nazwę profilu w pliku launchSettings.json do użycia. Jest to ignorowane, jeśli nie znaleziono pliku launchSettings.json. Plik launchSettings.json będzie odczytywany z określonej ścieżki, która powinna być właściwością „launchSettingsFilePath”, lub {cwd}/Properties/launchSettings.json, jeśli nie jest ustawiona. Jeśli ta opcja jest ustawiona na wartość null lub jest pustym ciągiem, wtedy plik launchSettings.json jest ignorowany. Jeśli ta wartość nie zostanie określona, zostanie użyty pierwszy profil „Project”.",
  "generateOptionsSchema.logging.browserStdOut.markdownDescription": "Flaga umożliwiająca określenie, czy tekst stdout z uruchamiania przeglądarki internetowej powinien być rejestrowany w oknie danych wyjściowych. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.logging.consoleUsageMessage.description": "Określa, czy komunikat jest rejestrowany, gdy proces docelowy wywołuje interfejs API „Console.Read*”, a stdin jest przekierowywane do konsoli.",
  "generateOptionsSchema.logging.description": "Flagi umożliwiające określenie, które typy komunikatów powinny być rejestrowane w oknie danych wyjściowych.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.all.enumDescription": "Drukuj wszystkie wywołania interfejsu API debugera. Jest to bardzo szczegółowe.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.error.enumDescription": "Błędy drukowania z wywołań interfejsu API debugera.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.markdownDescription": "Określa, czy wywołania interfejsu API do elementu Microsoft.VisualStudio.Debugger.Engine/vsdebugeng.h powinny być drukowane w oknie danych wyjściowych. Ta opcja domyślnie ma wartość „none”.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.none.enumDescription": "Wyłącz wywołania interfejsu API śledzenia",
  "generateOptionsSchema.logging.diagnosticsLog.debugRuntimeEventTracing.markdownDescription": "Flaga określająca, czy powinno być włączone pełne śledzenie zdarzeń wywoływanych przez bazowe środowisko uruchomieniowe. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.logging.diagnosticsLog.description": "Ustawienia określające, które komunikaty są drukowane w oknie danych wyjściowych z dziennika diagnostycznego debugera. Ten dziennik ma pomóc w rozwiązywaniu problemów z debugerem.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.error.enumDescription": "Drukuj komunikaty diagnostyczne na poziomie błędów.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.important.enumDescription": "Drukuj ważne komunikaty diagnostyczne.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.markdownDescription": "Określa, które komunikaty są drukowane w oknie danych wyjściowych od dyspozytora debugera. Jeśli nie zostanie określona, ustawienie domyślne będzie mieć wartość „none”, chyba że jest włączone jedno z ustawień pełnego dziennika („debugEngineAPITracing”, „debugRuntimeEventTracing”, „expressionEvaluationTracing” lub „startDebuggingTracing”), w którym to przypadku wartość domyślna zmieni się na „normal”.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.none.enumDescription": "Nie drukuj dodatkowych komunikatów diagnostycznych.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.normal.enumDescription": "Drukuj wszystkie nieszczegółowe komunikaty diagnostyczne.",
  "generateOptionsSchema.logging.diagnosticsLog.expressionEvaluationTracing.markdownDescription": "Flaga określająca, czy powinno być włączone pełne śledzenie oceny wyrażenia. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.logging.diagnosticsLog.protocolMessages.markdownDescription": "Flaga określająca, czy komunikaty protokołu DAP wymieniane między debugerem języka C# i interfejsem użytkownika powinny być rejestrowane w oknie danych wyjściowych. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.logging.diagnosticsLog.startDebuggingTracing.markdownDescription": "Flaga określająca, czy powinno być włączone pełne śledzenie uruchamiania debugowania. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.logging.elapsedTiming.markdownDescription": "Jeśli ma wartość true, rejestrowanie komunikatów protokołu będzie zawierać właściwości „adapterElapsedTime” i „engineElapsedTime”, aby wskazać czas, który zajęło żądanie w mikrosekundach. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.logging.engineLogging.deprecationMessage": "Ustawienie „logging.engineLogging” zostało uznane za przestarzałe na rzecz elementu „logging.diagnosticsLog.protocolMessages”.",
  "generateOptionsSchema.logging.exceptions.markdownDescription": "Flaga umożliwiająca określenie, czy komunikaty o wyjątkach powinny być rejestrowane w oknie danych wyjściowych. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.logging.moduleLoad.markdownDescription": "Flaga umożliwiająca określenie, czy zdarzenia ładowania modułu powinny być rejestrowane w oknie danych wyjściowych. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.logging.processExit.markdownDescription": "Określa, czy komunikat jest rejestrowany podczas kończenia procesu docelowego lub zatrzymywania debugowania. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.logging.programOutput.markdownDescription": "Flaga określająca, czy dane wyjściowe programu powinny być rejestrowane w oknie danych wyjściowych, gdy nie jest używana konsola zewnętrzna. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.logging.threadExit.markdownDescription": "Określa, czy komunikat jest rejestrowany po zakończeniu działania wątku w procesie docelowym. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.pipeTransport.debuggerPath.description": "Pełna ścieżka do debugera na komputerze docelowym.",
  "generateOptionsSchema.pipeTransport.description": "Jeśli jest obecny, zawiera instrukcje dla debugera, aby połączył się z komputerem zdalnym przy użyciu innego pliku wykonywalnego jako potoku, który będzie przekazywał standardowe dane wejściowe/wyjściowe między programem VS Code a plikiem wykonywalnym zaplecza debugera platformy .NET Core (vsdbg).",
  "generateOptionsSchema.pipeTransport.linux.description": "Opcje konfiguracji uruchamiania potoku specyficznego dla systemu Linux",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.0.description": "Argumenty wiersza polecenia przekazane do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.1.description": "Wersja konwertowana na ciąg argumentów wiersza polecenia przekazanych do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.linux.pipeCwd.description": "W pełni kwalifikowana ścieżka do katalogu roboczego dla programu potoku.",
  "generateOptionsSchema.pipeTransport.linux.pipeEnv.description": "Zmienne środowiskowe przekazywane do programu potoku.",
  "generateOptionsSchema.pipeTransport.linux.pipeProgram.description": "Polecenie w pełni kwalifikowanego potoku do wykonania.",
  "generateOptionsSchema.pipeTransport.linux.quoteArgs.description": "Czy argumenty zawierające znaki, które powinny być podawane (np. spacje), mają być podawane? Wartością domyślną jest „true”. W przypadku ustawienia na wartość false polecenie debugera nie będzie już automatycznie podawane.",
  "generateOptionsSchema.pipeTransport.osx.description": "Opcje konfiguracji uruchamiania potoku specyficznego dla systemu OSX",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.0.description": "Argumenty wiersza polecenia przekazane do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.1.description": "Wersja konwertowana na ciąg argumentów wiersza polecenia przekazanych do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.osx.pipeCwd.description": "W pełni kwalifikowana ścieżka do katalogu roboczego dla programu potoku.",
  "generateOptionsSchema.pipeTransport.osx.pipeEnv.description": "Zmienne środowiskowe przekazywane do programu potoku.",
  "generateOptionsSchema.pipeTransport.osx.pipeProgram.description": "Polecenie w pełni kwalifikowanego potoku do wykonania.",
  "generateOptionsSchema.pipeTransport.osx.quoteArgs.description": "Czy argumenty zawierające znaki, które powinny być podawane (np. spacje), mają być podawane? Wartością domyślną jest „true”. W przypadku ustawienia na wartość false polecenie debugera nie będzie już automatycznie podawane.",
  "generateOptionsSchema.pipeTransport.pipeArgs.0.description": "Argumenty wiersza polecenia przekazane do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.pipeArgs.1.description": "Wersja konwertowana na ciąg argumentów wiersza polecenia przekazanych do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.pipeCwd.description": "W pełni kwalifikowana ścieżka do katalogu roboczego dla programu potoku.",
  "generateOptionsSchema.pipeTransport.pipeEnv.description": "Zmienne środowiskowe przekazywane do programu potoku.",
  "generateOptionsSchema.pipeTransport.pipeProgram.description": "Polecenie w pełni kwalifikowanego potoku do wykonania.",
  "generateOptionsSchema.pipeTransport.quoteArgs.description": "Czy argumenty zawierające znaki, które powinny być podawane (np. spacje), mają być podawane? Wartością domyślną jest „true”. W przypadku ustawienia na wartość false polecenie debugera nie będzie już automatycznie podawane.",
  "generateOptionsSchema.pipeTransport.windows.description": "Opcje konfiguracji uruchamiania potoku specyficznego dla systemu Windows",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.0.description": "Argumenty wiersza polecenia przekazane do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.1.description": "Wersja konwertowana na ciąg argumentów wiersza polecenia przekazanych do programu potoku. Token ${debuggerCommand} w pipeArgs zostanie zastąpiony przez polecenie pełnego debugera. Ten token można określić śródwierszowo z innymi argumentami. Jeśli element ${debuggerCommand} nie jest używany w żadnym argumencie, polecenie pełnego debugera zamiast tego zostanie dodane na końcu listy argumentów.",
  "generateOptionsSchema.pipeTransport.windows.pipeCwd.description": "W pełni kwalifikowana ścieżka do katalogu roboczego dla programu potoku.",
  "generateOptionsSchema.pipeTransport.windows.pipeEnv.description": "Zmienne środowiskowe przekazywane do programu potoku.",
  "generateOptionsSchema.pipeTransport.windows.pipeProgram.description": "Polecenie w pełni kwalifikowanego potoku do wykonania.",
  "generateOptionsSchema.pipeTransport.windows.quoteArgs.description": "Czy argumenty zawierające znaki, które powinny być podawane (np. spacje), mają być podawane? Wartością domyślną jest „true”. W przypadku ustawienia na wartość false polecenie debugera nie będzie już automatycznie podawane.",
  "generateOptionsSchema.processId.0.markdownDescription": "Identyfikator procesu, do którego można dołączyć. Użyj znaku \"\", aby uzyskać listę uruchomionych procesów, do których można dołączyć. Jeśli jest używany element „processId”, nie należy używać elementu „processName”.",
  "generateOptionsSchema.processId.1.markdownDescription": "Identyfikator procesu, do którego można dołączyć. Użyj znaku \"\", aby uzyskać listę uruchomionych procesów, do których można dołączyć. Jeśli jest używany element „processId”, nie należy używać elementu „processName”.",
  "generateOptionsSchema.processName.markdownDescription": "Nazwa procesu, do którego można dołączyć. Jeśli jest używany, nie należy używać elementu „processId”.",
  "generateOptionsSchema.program.markdownDescription": "Ścieżka do biblioteki dll aplikacji lub pliku wykonywalnego hosta platformy .NET Core do uruchomienia.\r\nTa właściwość zwykle przyjmuje postać: \"${workspaceFolder}/bin/Debug/(target-framework)/(project-name.dll)\"\r\n\r\nPrzykład: '${workspaceFolder}/bin/Debug/netcoreapp1.1/MyProject.dll'\r\n\r\nGdzie:\r\n\"(target-framework)\" to platforma, dla której jest kompilowany debugowany projekt. Zwykle można to znaleźć w pliku projektu jako właściwość „TargetFramework”.\r\n\r\n\"(project-name.dll)\" to nazwa biblioteki dll danych wyjściowych kompilacji debugowanego projektu. Zwykle jest taka sama jak nazwa pliku projektu, ale z rozszerzeniem „.dll”.",
  "generateOptionsSchema.requireExactSource.markdownDescription": "Flaga wymagająca, aby bieżący kod źródłowy był zgodny z bazą danych pdb. Ta opcja jest ustawiona domyślnie na wartość „true”.",
  "generateOptionsSchema.sourceFileMap.markdownDescription": "Mapuje ścieżki czasu kompilacji z lokalnymi lokalizacjami źródłowymi. Wszystkie wystąpienia ścieżki czasu kompilacji zostaną zastąpione lokalną ścieżką źródłową.\r\n\r\nPrzykład:\r\n\r\n„{\"<build-path>\":\"<local-source-path>\"}”",
  "generateOptionsSchema.sourceLinkOptions.additionalItems.enabled.markdownDescription": "Czy dla tego adresu URL jest włączone narzędzie Source Link? Jeśli nie zostanie określone, ta opcja zostanie domyślnie ustawiona na wartość „true”.",
  "generateOptionsSchema.sourceLinkOptions.markdownDescription": "Opcje określające sposób łączenia Source Link z serwerami sieci Web. [Więcej infiormacji](https://aka.ms/VSCode-DotNet-SourceLink)",
  "generateOptionsSchema.stopAtEntry.markdownDescription": "W przypadku wartości true debuger powinien zostać zatrzymany w punkcie wejścia elementu docelowego. Ta opcja jest ustawiona domyślnie na wartość „false”.",
  "generateOptionsSchema.suppressJITOptimizations.markdownDescription": "W przypadku ustawienia na wartość true, gdy zoptymalizowany moduł (.dll skompilowany w konfiguracji wydania) zostanie załadowany w procesie docelowym, debuger poprosi kompilator JIT o wygenerowanie kodu z wyłączonymi optymalizacjami. [Więcej informacji](https://aka.ms/VSCode-CS-LaunchJson-SuppressJITOptimizations)",
  "generateOptionsSchema.symbolOptions.cachePath.description": "Katalog, w którym powinny być buforowane symbole pobrane z serwerów symboli. Jeśli nie zostanie określony, w systemie Windows debuger będzie domyślnie ustawiony na %TEMP%\\SymbolCache, a w systemach Linux i macOS debuger będzie domyślnie ustawiony na ~/.dotnet/symbolcache.",
  "generateOptionsSchema.symbolOptions.description": "Opcje umożliwiające kontrolowanie sposobu znajdowania i ładowania symboli (plików PDB).",
  "generateOptionsSchema.symbolOptions.moduleFilter.description": "Udostępnia opcje umożliwiające kontrolowanie modułów (plików DLL), dla których debuger będzie próbował załadować symbole (pliki PDB).",
  "generateOptionsSchema.symbolOptions.moduleFilter.excludedModules.description": "Tablica modułów, dla których debuger NIE powinien ładować symboli. Symbole wieloznaczne (przykład: MojaFirma.*.dll) są obsługiwane.\r\n\r\nTa właściwość jest ignorowana, chyba że właściwość „mode” jest ustawiona na wartość „loadAllButExcluded”.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsNextToModules.description": "Jeśli ma wartość true, w przypadku każdego modułu NIE BĘDĄCEGO w tablicy „includedModules” debuger będzie nadal sprawdzał obok modułu i uruchamianego pliku wykonywalnego, ale nie będzie sprawdzał ścieżek na liście wyszukiwania symboli. Ta opcja ma wartość domyślną „true”.\r\n\r\nTa właściwość jest ignorowana, chyba że właściwość „mode” jest ustawiona na wartość „loadOnlyIncluded”.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsOnDemand.description": "Jeśli wartość jest równa true, w przypadku dowolnego modułu NOT w tablicy „includedModules” debuger podejmie próbę pobrania symboli, gdy wykryje, że są potrzebne symbole, na przykład podczas próby wejścia do modułu. Ta opcja domyślnie ma wartość „true”.\r\n\r\nTa właściwość jest ignorowana, chyba że właściwość „mode” jest ustawiona na wartość „loadOnlyIncluded”.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includedModules.description": "Tablica modułów, dla których debuger powinien ładować symbole. Symbole wieloznaczne (przykład: MojaFirma.*.dll) są obsługiwane.\r\n\r\nTa właściwość jest ignorowana, chyba że właściwość „mode” jest ustawiona na wartość „loadOnlyIncluded”.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.description": "Steruje dwoma podstawowymi trybami operacyjnymi, w których działa filtr modułu.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadAllButExcluded.enumDescription": "Załaduj symbole dla wszystkich modułów, jeśli moduł nie znajduje się w tablicy „excludedModules”.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadOnlyIncluded.enumDescription": "Nie próbuj ładować symboli dla ŻADNEGO modułu, jeśli nie znajduje się w tablicy „includedModules” lub jest ono uwzględniane przez ustawienie „includeSymbolsNextToModules”.",
  "generateOptionsSchema.symbolOptions.searchMicrosoftSymbolServer.description": "W przypadku wartości „true” serwer symboli firmy Microsoft (https​://msdl.microsoft.com​/download/symbols) zostanie dodany do ścieżki wyszukiwania symboli. Jeśli ta opcja nie zostanie określona, domyślnie zostanie wybrana wartość „false”.",
  "generateOptionsSchema.symbolOptions.searchNuGetOrgSymbolServer.description": "W przypadku ustawienia na wartość „true” serwer symboli NuGet.org (https​://symbols.nuget.org​/download/symbols) zostanie dodany do ścieżki wyszukiwania symboli. Jeśli ta opcja nie zostanie określona, domyślnie zostanie ustawiona na wartość „false”.",
  "generateOptionsSchema.symbolOptions.searchPaths.description": "Tablica adresów URL serwera symboli (przykład: http​://MyExampleSymbolServer) lub katalogi (przykład: /build/symbols), aby wyszukać pliki .pdb. Te katalogi będą przeszukiwane oprócz lokalizacji domyślnych — obok modułu i ścieżki, do której pierwotnie przeniesiono plik pdb.",
  "generateOptionsSchema.targetArchitecture.markdownDescription": "[Obsługiwane tylko w przypadku debugowania lokalnego systemu macOS]\r\n\r\nArchitektura obiektu debugowanego. Zostanie automatycznie wykryta, chyba że ten parametr jest ustawiony. Dozwolone wartości to „x86_64” lub „arm_64”.",
  "generateOptionsSchema.targetOutputLogPath.description": "Po ustawieniu tekst, który aplikacja docelowa zapisuje w stdout i stderr (np. Console.WriteLine), zostanie zapisany w określonym pliku. Ta opcja jest ignorowana, jeśli konsola jest ustawiona na wartość inną niż internalConsole, np. \"${workspaceFolder}/out.txt\"",
  "generateOptionsSchema.type.markdownDescription": "Wpisz typ kodu do debugowania. Może to być „coreclr” na potrzeby debugowania platformy .NET Core lub „clr” dla platformy klasycznej .NET Framework. Element „clr” działa tylko w systemie Windows, ponieważ platforma klasyczna działa tylko w systemie Windows.",
  "viewsWelcome.debug.contents": "[Generuj zasoby języka C# na potrzeby kompilacji i debugowania](polecenie:dotnet.generateAssets)\r\n\r\nAby dowiedzieć się więcej o uruchamianiu pliku launch.json, zobacz [Konfigurowanie pliku launch.json na potrzeby debugowania w języku C#](https://aka.ms/VSCode-CS-LaunchJson)."
}