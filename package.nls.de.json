{
  "command.csharp.attachToProcess": "An einen .NET 5+ oder .NET Core-Prozess anfügen",
  "command.csharp.downloadDebugger": ".NET Core-Debugger herunterladen",
  "command.csharp.listProcess": "Prozess zum Anfügen auflisten",
  "command.csharp.listRemoteDockerProcess": "Prozesse für Docker-Verbindung auflisten",
  "command.csharp.listRemoteProcess": "Prozesse für Remoteverbindung zum Anfügen auflisten",
  "command.csharp.reportIssue": "Ein Problem melden",
  "command.csharp.showDecompilationTerms": "Vereinbarung zu den Decompilerbedingungen anzeigen",
  "command.dotnet.generateAssets.currentProject": "Ressourcen für Build und Debuggen generieren",
  "command.dotnet.openSolution": "Projektmappe öffnen",
  "command.dotnet.restartServer": "Sprachserver neu starten",
  "command.dotnet.restore.all": "Alle Projekte wiederherstellen",
  "command.dotnet.restore.project": "Projekt wiederherstellen",
  "command.dotnet.test.debugTestsInContext": "Tests im Kontext debuggen",
  "command.dotnet.test.runTestsInContext": "Tests im Kontext ausführen",
  "command.extension.showRazorCSharpWindow": "Razor CSharp anzeigen",
  "command.extension.showRazorHtmlWindow": "Razor-HTML anzeigen",
  "command.o.fixAll.document": "Alle Vorkommen eines Codeproblems innerhalb des Dokuments beheben",
  "command.o.fixAll.project": "Alle Vorkommen eines Codeproblems innerhalb des Projekts beheben",
  "command.o.fixAll.solution": "Alle Vorkommen eines Codeproblems innerhalb der Projektmappe beheben",
  "command.o.pickProjectAndStart": "Projekt auswählen",
  "command.o.reanalyze.allProjects": "Alle Projekte analysieren",
  "command.o.reanalyze.currentProject": "Aktuelles Projekt analysieren",
  "command.o.restart": "OmniSharp neu starten",
  "command.razor.reportIssue": "Razor-Problem melden",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitObjectCreation": "Hinweise für die implizite Objekterstellung anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitVariableTypes": "Hinweise für Variablen mit abgeleiteten Typen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForIndexerParameters": "Hinweise für Indexer anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForLambdaParameterTypes": "Hinweise für Lambda-Parametertypen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForTypes": "Inlinetyphinweise anzeigen",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope": "Ausführen der Hintergrundcodeanalyse für: (Zuvor \"omnisharp.enableRoslynAnalyzers\")",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope": "Compilerfehler und -warnungen anzeigen für:",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.codeLens.enableReferencesCodeLens": "Gibt an, ob die Verweise auf CodeLens angezeigt werden sollen. (Zuvor \"csharp.referencesCodeLens.enabled\")",
  "configuration.dotnet.codeLens.enableTestsCodeLens": "Gibt an, ob der CodeLens-Test zum Ausführen und Debuggen angezeigt werden soll. (Zuvor \"csharp.testsCodeLens.enabled\")",
  "configuration.dotnet.completion.provideRegexCompletions": "Reguläre Ausdrücke in der Vervollständigungsliste anzeigen.",
  "configuration.dotnet.completion.showCompletionItemsFromUnimportedNamespaces": "Ermöglicht die Anzeige nicht importierter Typen und nicht importierter Erweiterungsmethoden in Vervollständigungslisten. Wenn ein Commit ausgeführt wird, wird die entsprechende using-Direktive am Anfang der aktuellen Datei hinzugefügt. (Zuvor \"omnisharp.enableImportCompletion\")",
  "configuration.dotnet.completion.showNameCompletionSuggestions": "Führen Sie die automatische Vervollständigung des Objektnamens für die Elemente aus, die Sie kürzlich ausgewählt haben.",
  "configuration.dotnet.defaultSolution.description": "Der Pfad der Standardlösung, die im Arbeitsbereich geöffnet werden soll, oder auf \"deaktivieren\" festlegen, um sie zu überspringen. (Zuvor \"omnisharp.defaultLaunchSolution\")",
  "configuration.dotnet.dotnetPath": "Gibt den Pfad zu einem dotnet-Installationsverzeichnis an, das anstelle des Standardsystems verwendet werden soll. Dies wirkt sich nur auf die dotnet-Installation aus, die zum Hosten des Sprachservers selbst verwendet werden soll. Beispiel: \"/home/username/mycustomdotnetdirectory\".",
  "configuration.dotnet.highlighting.highlightRelatedJsonComponents": "Zugehörige JSON-Komponenten unter dem Cursor markieren.",
  "configuration.dotnet.highlighting.highlightRelatedRegexComponents": "Zugehörige Komponenten regulärer Ausdrücke unter dem Cursor markieren.",
  "configuration.dotnet.implementType.insertionBehavior": "Die Einfügeposition von Eigenschaften, Ereignissen und Methoden beim Implementieren der Schnittstelle oder abstrakten Klasse.",
  "configuration.dotnet.implementType.insertionBehavior.atTheEnd": "Platzieren Sie sie am Ende.",
  "configuration.dotnet.implementType.insertionBehavior.withOtherMembersOfTheSameKind": "Platzieren Sie sie mit anderen Mitgliedern derselben Art.",
  "configuration.dotnet.implementType.propertyGenerationBehavior": "Generierungsverhalten von Eigenschaften beim Implementieren einer Schnittstelle oder einer abstrakten Klasse.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferAutoProperties": "Automatische Eigenschaften bevorzugen.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferThrowingProperties": "Ausgelöste Eigenschaften bevorzugen.",
  "configuration.dotnet.inlayHints.enableInlayHintsForLiteralParameters": "Hinweise für Literale anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": "Hinweise für new-Ausdrücke anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForOtherParameters": "Hinweise für alles andere anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForParameters": "Hinweise zu Inlineparameternamen anzeigen",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatDifferOnlyBySuffix": "Hinweise unterdrücken, wenn sich Parameternamen nur durch das Suffix unterscheiden",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchArgumentName": "Hinweise unterdrücken, wenn das Argument mit dem Namen des Parameters übereinstimmt",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchMethodIntent": "Hinweise unterdrücken, wenn der Parametername mit der Methodenabsicht übereinstimmt",
  "configuration.dotnet.navigation.navigateToDecompiledSources": "Aktivieren der Navigation zu dekompilierten Quellen.",
  "configuration.dotnet.preferCSharpExtension": "Erzwingt, dass Projekte nur mit der C#-Erweiterung geladen werden.  Dies kann nützlich sein, wenn Legacy-Projekttypen verwendet werden, die vom C# Dev Kit nicht unterstützt werden. (Erfordert erneutes Laden des Fensters)",
  "configuration.dotnet.quickInfo.showRemarksInQuickInfo": "Beschreibungsinformationen beim Anzeigen des Symbols anzeigen.",
  "configuration.dotnet.server.crashDumpPath": "Legt einen Ordnerpfad fest, in den Absturzabbilder geschrieben werden, wenn der Sprachserver abstürzt.  Muss vom Benutzer beschreibbar sein.",
  "configuration.dotnet.server.extensionPaths": "Außerkraftsetzung für Pfad zu Sprachserver --extension-Argumenten",
  "configuration.dotnet.server.path": "Gibt den absoluten Pfad zur ausführbaren Serverdatei (LSP oder O#) an. Wenn sie leer gelassen wird, wird die an die C#-Erweiterung angeheftete Version verwendet. (Zuvor \"omnisharp.path\")",
  "configuration.dotnet.server.startTimeout": "Gibt ein Timeout (in ms) an, mit dem der Client erfolgreich gestartet und eine Verbindung mit dem Sprachserver hergestellt werden kann.",
  "configuration.dotnet.server.trace": "Legt den Protokolliergrad für den Sprachserver fest.",
  "configuration.dotnet.server.waitForDebugger": "Übergibt das Flag \"--debug\" beim Starten des Servers, damit ein Debugger angefügt werden kann. (Zuvor \"omnisharp.waitForDebugger\")",
  "configuration.dotnet.symbolSearch.searchReferenceAssemblies": "Symbole in Verweisassemblys suchen. Dies wirkt sich auf Features aus, die eine Symbolsuche erfordern, z. B. Importe hinzufügen.",
  "configuration.dotnet.unitTestDebuggingOptions": "Optionen, die mit dem Debugger beim Starten des Komponententestdebuggings verwendet werden können. (Zuvor \"csharp.unitTestDebuggingOptions\")",
  "configuration.razor.languageServer.debug": "Gibt an, ob beim Starten des Sprachservers auf die Debuganfügung gewartet werden soll.",
  "configuration.razor.languageServer.directory": "Überschreibt den Pfad zum Razor-Sprachserver-Verzeichnis.",
  "configuration.razor.trace": "Gibt an, ob alle Nachrichten [Verbose], einige Nachrichten [Messages] oder gar nicht [Off] ausgegeben werden sollen.",
  "configuration.razor.trace.messages": "Protokolliert nur einige Nachrichten von der Razor-Erweiterung.",
  "configuration.razor.trace.off": "Protokolliert keine Nachrichten von der Razor-Erweiterung.",
  "configuration.razor.trace.verbose": "Protokolliert alle Nachrichten aus der Razor-Erweiterung.",
  "debuggers.coreclr.configurationSnippets.description.attach": "Fügen Sie den .NET-Debugger (coreclr) an einen laufenden Prozess an. Dies kann auch mit dem Befehl \"An einen .NET 5+- oder .NET Core-Prozess anfügen\" erfolgen.",
  "debuggers.coreclr.configurationSnippets.description.blazor-hosted": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem Blazor WebAssembly-Debugger (blazorwasm) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel kann jedoch verwendet werden, um Vollzugriff auf alle Startoptionen zu erhalten. Dieser Codeschnipsel ist für gehostete Blazor-Projekte vorgesehen. Dabei handelt es sich um ein Projekt, das im Back-End über eine ASP.NET Core-App zum Verarbeiten der Dateien verfügt.",
  "debuggers.coreclr.configurationSnippets.description.blazor-standalone": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem Blazor WebAssembly-Debugger (blazorwasm) zu starten. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel kann jedoch verwendet werden, um Vollzugriff auf alle Startoptionen zu erhalten. Dieser Codeschnipsel ist für eigenständige Blazor-Projekte vorgesehen. Dabei handelt es sich um ein Projekt, das im Back-End über keine ASP.NET Core-App zum Verarbeiten der Dateien verfügt.",
  "debuggers.coreclr.configurationSnippets.description.console-local": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem .NET-Debugger (coreclr) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel ist nützlich, wenn das Projekt außerhalb dieser VS Code-Instanz erstellt wurde, wenn Sie Ihren .NET-Code in einer benutzerdefinierten ausführbaren Datei (z. B. in einer bestimmten Version von \"dotnet.exe\"/\"dotnet\") hosten möchten oder wenn der .NET-Code von einer nativen Anwendung gehostet wird. Dieser Codeschnipsel ist für Konsolenanwendungen vorgesehen.",
  "debuggers.coreclr.configurationSnippets.description.remote": "Dieser Codeschnipsel zeigt, wie Sie ein Remotedebuggen von .NET Code **ohne** die Remotefunktion von VS Code durchführen. Dies sollte in Fällen verwendet werden, in denen Sie Ihr Projekt lokal erstellen, aber auf einem anderen Computer ausführen möchten.",
  "debuggers.coreclr.configurationSnippets.description.web-local": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem .NET-Debugger (coreclr) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel ist nützlich, wenn das Projekt außerhalb dieser VS Code-Instanz erstellt wurde, wenn Sie Ihren .NET-Code in einer benutzerdefinierten ausführbaren Datei (z. B. in einer bestimmten Version von \"dotnet.exe\"/\"dotnet\") hosten möchten oder wenn der .NET-Code von einer nativen Anwendung gehostet wird. Dieser Codeschnipsel ist für Webanwendungen (ASP.NET Core) geeignet.",
  "debuggers.coreclr.configurationSnippets.label.attach-local": ".NET: An einen .NET-Prozess anfügen",
  "debuggers.coreclr.configurationSnippets.label.attach-remote": ".NET: Remotedebuggen – An .NET-Prozess anfügen",
  "debuggers.coreclr.configurationSnippets.label.blazor-hosted": ".NET: Webassembly – Gehostetes Blazor-Projekt starten",
  "debuggers.coreclr.configurationSnippets.label.blazor-standalone": ".NET: Webassembly – Eigenständiges Blazor-Projekt starten",
  "debuggers.coreclr.configurationSnippets.label.console-local": ".NET: Ausführbare Datei starten (Konsole)",
  "debuggers.coreclr.configurationSnippets.label.console-remote": ".NET: Remotedebuggen – Ausführbare Datei starten (Konsole)",
  "debuggers.coreclr.configurationSnippets.label.web-local": ".NET: Ausführbare Datei starten (Web)",
  "debuggers.dotnet.configurationSnippets.description": "Dieser Codeschnipsel konfiguriert VS Code für das Debuggen eines C#-Projekts. Debugoptionen (zum Beispiel Argumente für die ausführbare Datei) können über die Datei '<project-directory>/Properties/launchSettings.json' konfiguriert werden.",
  "debuggers.dotnet.configurationSnippets.label": ".NET: C#-Projekt starten",
  "debuggers.dotnet.launch.launchConfigurationId.description": "Die zu verwendende Startkonfigurations-ID. Eine leere Zeichenfolge verwendet die aktuelle aktive Konfiguration.",
  "debuggers.dotnet.launch.projectPath.description": "Pfad zur CSPROJ-Datei.",
  "generateOptionsSchema.allowFastEvaluate.description": "Bei \"true\" (Standardzustand) versucht der Debugger eine schnellere Auswertung, indem er die Ausführung einfacher Eigenschaften und Methoden simuliert.",
  "generateOptionsSchema.args.0.description": "Befehlszeilenargumente, die an das Programm übergeben werden.",
  "generateOptionsSchema.args.1.description": "An das Programm übergebene Zeichenfolgenversion von Befehlszeilenargumenten.",
  "generateOptionsSchema.checkForDevCert.description": "Wenn Sie ein Webprojekt unter Windows oder macOS starten und dies aktiviert ist, überprüft der Debugger, ob der Computer über ein selbstsigniertes HTTPS-Zertifikat verfügt, das zum Entwickeln von Webservern verwendet wird, die auf HTTPS-Endpunkten ausgeführt werden. Wenn nicht angegeben, wird standardmäßig \"true\" verwendet, wenn \"serverReadyAction\" festgelegt ist. Mit dieser Option werden keine Linux-, VS Code-Remote- und VS Code-Webbenutzeroberflächenszenarien ausgeführt. Wenn das HTTPS-Zertifikat nicht gefunden wird oder nicht vertrauenswürdig ist, wird der Benutzer aufgefordert, es zu installieren bzw. ihm zu vertrauen.",
  "generateOptionsSchema.console.externalTerminal.enumDescription": "Externes Terminal, das über Benutzereinstellungen konfiguriert werden kann.",
  "generateOptionsSchema.console.integratedTerminal.enumDescription": "Das integrierte Terminal von VS Code.",
  "generateOptionsSchema.console.internalConsole.enumDescription": "Ausgabe an den VS Code-Debugging-Konsole. Das Lesen von Konsoleneingaben (z. B. Console.ReadLine) wird nicht unterstützt.",
  "generateOptionsSchema.console.markdownDescription": "Gibt beim Starten von Konsolenprojekten an, in welcher Konsole das Zielprogramm gestartet werden soll.",
  "generateOptionsSchema.console.settingsDescription": "**Hinweis:** _This Option wird nur für die Debugkonfiguration \"dotnet\" type_ verwendet.\r\n\r\nGibt beim Starten von Konsolenprojekten an, in welcher Konsole das Zielprogramm gestartet werden soll.",
  "generateOptionsSchema.cwd.description": "Pfad zum Arbeitsverzeichnis des Programms, das gedebuggt wird. Der Standardwert ist der aktuelle Arbeitsbereich.",
  "generateOptionsSchema.enableStepFiltering.markdownDescription": "Kennzeichnung zum Aktivieren des Schrittweisen Ausführens von Eigenschaften und Operatoren. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.env.description": "Umgebungsvariablen, die an das Programm übergeben werden.",
  "generateOptionsSchema.envFile.markdownDescription": "Umgebungsvariablen, die von einer Datei an das Programm übergeben werden. Beispiel: \"${workspaceFolder}/.env\"",
  "generateOptionsSchema.externalConsole.markdownDescription": "Das Attribut \"externalConsole\" ist veraltet. Verwenden Sie stattdessen \"console\". Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.justMyCode.markdownDescription": "Wenn diese Option aktiviert ist (Standardeinstellung), wird der Debugger nur angezeigt und in den Benutzercode (\"Mein Code\") eingeschritten. Dabei werden Systemcode und anderer Code ignoriert, der optimiert ist oder über keine Debugsymbole verfügt. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson-JustMyCode)",
  "generateOptionsSchema.launchBrowser.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Dies wird nur verwendet, wenn das plattformspezifische Element (\"osx\", \"linux\" oder \"windows\") keinen Wert für \"args\" angibt. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.description": "Beschreibt Optionen zum Starten eines Webbrowsers als Teil des Starts.",
  "generateOptionsSchema.launchBrowser.enabled.description": "Gibt an, ob das Starten des Webbrowsers aktiviert ist. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.launchBrowser.linux.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.linux.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.linux.description": "Linux-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"xdg-open\" gestartet.",
  "generateOptionsSchema.launchBrowser.osx.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.osx.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.osx.description": "OSX-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"open\" gestartet.",
  "generateOptionsSchema.launchBrowser.windows.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.windows.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.windows.description": "Windows-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"cmd /c start\" gestartet.",
  "generateOptionsSchema.launchSettingsFilePath.markdownDescription": "Der Pfad zu einer Datei \"launchSettings.json\". Wenn dies nicht festgelegt ist, sucht der Debugger in \"{cwd}/Properties/launchSettings.json\".",
  "generateOptionsSchema.launchSettingsProfile.description": "Gibt bei Angabe den Namen des Profils in \"launchSettings.json\" an, das verwendet werden soll. Dies wird ignoriert, wenn launchSettings.json nicht gefunden wird. \"launchSettings.json\" wird aus dem angegebenen Pfad gelesen. Dabei muss es sich um die Eigenschaft \"launchSettingsFilePath\" oder um {cwd}/Properties/launchSettings.json handeln, wenn dies nicht festgelegt ist. Wenn dieser Wert auf NULL oder eine leere Zeichenfolge festgelegt ist, wird launchSettings.json ignoriert. Wenn dieser Wert nicht angegeben ist, wird das erste Projekt-Profil verwendet.",
  "generateOptionsSchema.logging.browserStdOut.markdownDescription": "Kennzeichnung, um zu bestimmen, ob stdout-Text vom Start des Webbrowsers im Ausgabefenster protokolliert werden soll. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.consoleUsageMessage.description": "Steuert, ob eine Nachricht protokolliert wird, wenn der Zielprozess eine Console.Read*-API aufruft und stdin an die Konsole umgeleitet wird.",
  "generateOptionsSchema.logging.description": "Kennzeichnungen, um zu bestimmen, welche Nachrichtentypen im Ausgabefenster protokolliert werden sollen.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.all.enumDescription": "Hiermit werden alle Debugger-API-Aufrufe ausgegeben. Diese Option ist sehr ausführlich.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.error.enumDescription": "Hiermit werden Fehler aus Debugger-API-Aufrufen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.markdownDescription": "Steuert, ob API-Aufrufe an \"Microsoft.VisualStudio.Debugger.Engine/vsdebugeng.h\" im Ausgabefenster ausgegeben werden sollen. Diese Option ist standardmäßig auf \"none\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.none.enumDescription": "Ablaufverfolgung für API-Aufrufe deaktivieren",
  "generateOptionsSchema.logging.diagnosticsLog.debugRuntimeEventTracing.markdownDescription": "Flag, mit dem festgelegt wird, ob die ausführliche Ablaufverfolgung für Ereignisse aktiviert werden soll, die von der zugrunde liegenden Runtime ausgelöst werden. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.description": "Einstellungen, mit denen festgelegt wird, welche Meldungen aus dem Diagnoseprotokoll des Debuggers im Ausgabefenster ausgegeben werden. Dieses Protokoll dient zur Unterstützung bei der Behandlung von Problemen mit dem Debugger.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.error.enumDescription": "Hiermit werden Diagnosemeldungen auf Fehlerebene ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.important.enumDescription": "Hiermit werden wichtige Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.markdownDescription": "Steuert, welche Meldungen vom Dispatcher des Debuggers im Ausgabefenster ausgegeben werden. Sofern nicht angegeben, wird standardmäßig \"none\" verwendet – es sei denn, eine der ausführlichen Protokolleinstellungen ist aktiviert (\"debugEngineAPITracing\", \"debugRuntimeEventTracing\", \"expressionEvaluationTracing\" oder \"startDebuggingTracing\"). In diesem Fall wird der Standardwert in \"normal\" geändert.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.none.enumDescription": "Hiermit werden keine zusätzlichen Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.normal.enumDescription": "Hiermit werden alle nicht ausführlichen Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.expressionEvaluationTracing.markdownDescription": "Flag, mit dem festgelegt wird, ob die ausführliche Ablaufverfolgung für die Ausdrucksauswertung aktiviert werden soll. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.protocolMessages.markdownDescription": "Flag, mit dem festgelegt wird, ob die zwischen dem C#-Debugger und der Benutzeroberfläche ausgetauschten DAP-Protokollnachrichten im Ausgabefenster protokolliert werden sollen. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.startDebuggingTracing.markdownDescription": "Flag zur Festlegung, ob die ausführliche Ablaufverfolgung beim Starten des Debuggens aktiviert werden soll. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.elapsedTiming.markdownDescription": "Bei einer Festlegung auf \"true\" umfasst die Nachrichtenprotokollierung die Eigenschaften \"adapterElapsedTime\" und \"engineElapsedTime\", um die Zeitspanne in Mikrosekunden anzugeben, die für eine Anforderung benötigt wurde. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.engineLogging.deprecationMessage": "Die Einstellung \"logging.engineLogging\" wurde zugunsten von \"logging.diagnosticsLog.protocolMessages\" als veraltet eingestuft.",
  "generateOptionsSchema.logging.exceptions.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Ausnahmemeldungen im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.moduleLoad.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Modulladeereignisse im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.processExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn der Zielprozess beendet oder das Debuggen beendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.programOutput.markdownDescription": "Kennzeichnung, um zu bestimmen, ob die Programmausgabe im Ausgabefenster protokolliert werden soll, wenn keine externe Konsole verwendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.threadExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn ein Thread im Zielprozess beendet wird. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.pipeTransport.debuggerPath.description": "Der vollständige Pfad zum Debugger auf dem Zielcomputer.",
  "generateOptionsSchema.pipeTransport.description": "Wenn vorhanden, weist dies den Debugger an, eine Verbindung mit einem Remotecomputer mithilfe einer anderen ausführbaren Datei als Pipe herzustellen, die die Standardeingabe/-ausgabe zwischen VS Code und der ausführbaren .NET Core-Debugger-Back-End-Datei (vsdbg) weiterleitet.",
  "generateOptionsSchema.pipeTransport.linux.description": "Linux-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.linux.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.linux.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.linux.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.osx.description": "OSX-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.osx.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.osx.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.osx.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.windows.description": "Windows-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.windows.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.windows.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.windows.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.processId.0.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processId.1.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processName.markdownDescription": "Der Prozessname, an den angefügt werden soll. Wenn dies verwendet wird, sollte \"processId\" nicht verwendet werden.",
  "generateOptionsSchema.program.markdownDescription": "Pfad zur Anwendungs-DLL oder ausführbaren .NET Core-Hostdatei, die gestartet werden soll.\r\nDiese Eigenschaft hat normalerweise folgendes Format: \"${workspaceFolder}/bin/Debug/(target-framework)/(project-name.dll)\"\r\n\r\nBeispiel: \"`${workspaceFolder}/bin/Debug/netcoreapp1.1/MyProject.dll`\r\n\r\nWo:\r\n\"(target-framework)\" ist das Framework, für das das debuggte Projekt erstellt wird. Dies wird normalerweise in der Projektdatei als TargetFramework-Eigenschaft gefunden.\r\n\r\n\"(project-name.dll)\" ist der Name der Buildausgabe-DLL des debuggten Projekts. Dies ist normalerweise identisch mit dem Projektdateinamen, aber mit der Erweiterung \".dll\".",
  "generateOptionsSchema.requireExactSource.markdownDescription": "Kennzeichnung, dass der aktuelle Quellcode dem PDB entsprechen muss. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceFileMap.markdownDescription": "Ordnet Buildzeitpfade lokalen Quellspeicherorten zu. Alle Instanzen des Buildzeitpfads werden durch den lokalen Quellpfad ersetzt.\r\n\r\nBeispiel:\r\n\r\n'{\"<build-path>\":\"<local-source-path>\"}'",
  "generateOptionsSchema.sourceLinkOptions.additionalItems.enabled.markdownDescription": "Ist Source Link für diese URL aktiviert? Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceLinkOptions.markdownDescription": "Optionen zum Steuern der Verbindung von Source Link mit Webservern. [Weitere Informationen](https://aka.ms/VSCode-DotNet-SourceLink)",
  "generateOptionsSchema.stopAtEntry.markdownDescription": "Bei \"true\" sollte der Debugger am Einstiegspunkt des Ziels beendet werden. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.suppressJITOptimizations.markdownDescription": "Bei \"true\" fordert der Debugger den Just-In-Time-Compiler auf, Code mit deaktivierten Optimierungen zu generieren, wenn ein optimiertes Modul (DLL- kompiliert in der Releasekonfiguration) im Zielprozess geladen wird. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson-SuppressJITOptimizations)",
  "generateOptionsSchema.symbolOptions.cachePath.description": "Verzeichnis, in dem von Symbolservern heruntergeladene Symbole zwischengespeichert werden sollen. Wenn nicht angegeben, wird der Debugger unter Windows standardmäßig auf %TEMP%\\SymbolCache festgelegt, und unter Linux und macOS wird der Debugger standardmäßig auf ~/.dotnet/symbolcache festgelegt.",
  "generateOptionsSchema.symbolOptions.description": "Optionen zum Steuern, wie Symbole (PDB-Dateien) gefunden und geladen werden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.description": "Stellt Optionen bereit, um zu steuern, für welche Module (DLL-Dateien) der Debugger versuchen soll, Symbole (PDB-Dateien) zu laden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.excludedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadAllButExcluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsNextToModules.description": "Wenn „true“, wird der Debugger für ein beliebiges Modul, das sich NICHT im Array „includedModules“ befindet, weiterhin neben dem Modul selbst und der ausführbaren Datei, die gestartet wird, überprüfen. Die Pfade in der Symbolsuchliste werden jedoch nicht überprüft. Diese Option ist standardmäßig auf „true“ eingestellt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.description": "Steuert, in welchem der beiden grundlegenden Betriebsmodi der Modulfilter ausgeführt wird.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadAllButExcluded.enumDescription": "Laden Sie Symbole für alle Module, es sei denn, das Modul befindet sich im Array „excludedModules“.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadOnlyIncluded.enumDescription": "Versuchen Sie nicht, Symbole für IRGENDEIN Modul zu laden, es sei denn, es befindet sich im Array „includedModules“, oder es wird über die Einstellung „includeSymbolsNextToModules“ hinzugefügt.",
  "generateOptionsSchema.symbolOptions.searchMicrosoftSymbolServer.description": "Wenn „true“, wird der Microsoft-Symbolserver (https​://msdl.microsoft.com​/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn nicht angegeben, wird diese Option standardmäßig auf „false“ eingestellt.",
  "generateOptionsSchema.symbolOptions.searchNuGetOrgSymbolServer.description": "Bei \"true\" wird der NuGet.org-Symbolserver (https​://symbols.nuget.org​/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.symbolOptions.searchPaths.description": "Array von Symbolserver-URLs (example: http​://MyExampleSymbolServer) oder Verzeichnisse (example: /build/symbols), um nach PDB-Dateien zu suchen. Diese Verzeichnisse werden zusätzlich zu den Standardspeicherorten durchsucht – neben dem Modul und dem Pfad, in dem die PDB-Datei ursprünglich abgelegt wurde.",
  "generateOptionsSchema.targetArchitecture.markdownDescription": "[Nur beim lokalen macOS-Debuggen unterstützt]\r\n\r\nDie Architektur des Debuggens. Dies wird automatisch erkannt, es sei denn, dieser Parameter ist festgelegt. Zulässige Werte sind \"x86_64\" oder \"arm64\".",
  "generateOptionsSchema.targetOutputLogPath.description": "Bei Festlegung wird Text, den die Zielanwendung in \"stdout\" und \"stderr\" (z. B. Console.WriteLine) schreibt, in der angegebenen Datei gespeichert. Diese Option wird ignoriert, wenn die Konsole auf einen anderen Wert als internalConsole festgelegt ist. Beispiel: \"${workspaceFolder}/out.txt\"",
  "viewsWelcome.debug.contents": "[C#-Objekte für Build und Debuggen generieren](command:dotnet.generateAssets)\r\n\r\nWeitere Informationen zu launch.json finden Sie unter [Konfigurieren von launch.json für das C#-Debuggen](https://aka.ms/VSCode-CS-LaunchJson)."
}