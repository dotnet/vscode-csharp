{
  "command.csharp.attachToProcess": "An einen .NET 5+ oder .NET Core-Prozess anfügen",
  "command.csharp.downloadDebugger": ".NET Core-Debugger herunterladen",
  "command.csharp.listProcess": "Prozess zum Anfügen auflisten",
  "command.csharp.listRemoteDockerProcess": "Prozesse für Docker-Verbindung auflisten",
  "command.csharp.listRemoteProcess": "Prozesse für Remoteverbindung zum Anfügen auflisten",
  "command.csharp.recordLanguageServerTrace": "Leistungsablaufverfolgung des C#-Sprachservers aufzeichnen",
  "command.csharp.reportIssue": "Ein Problem melden",
  "command.csharp.showDecompilationTerms": "Vereinbarung zu den Decompilerbedingungen anzeigen",
  "command.dotnet.generateAssets.currentProject": "Ressourcen für Build und Debuggen generieren",
  "command.dotnet.openSolution": "Projektmappe öffnen",
  "command.dotnet.restartServer": "Sprachserver neu starten",
  "command.dotnet.restore.all": "Alle Projekte wiederherstellen",
  "command.dotnet.restore.project": "Projekt wiederherstellen",
  "command.dotnet.test.debugTestsInContext": "Tests im Kontext debuggen",
  "command.dotnet.test.runTestsInContext": "Tests im Kontext ausführen",
  "command.extension.showRazorCSharpWindow": "Razor CSharp anzeigen",
  "command.extension.showRazorHtmlWindow": "Razor-HTML anzeigen",
  "command.o.fixAll.document": "Alle Vorkommen eines Codeproblems innerhalb des Dokuments beheben",
  "command.o.fixAll.project": "Alle Vorkommen eines Codeproblems innerhalb des Projekts beheben",
  "command.o.fixAll.solution": "Alle Vorkommen eines Codeproblems innerhalb der Projektmappe beheben",
  "command.o.pickProjectAndStart": "Projekt auswählen",
  "command.o.reanalyze.allProjects": "Alle Projekte analysieren",
  "command.o.reanalyze.currentProject": "Aktuelles Projekt analysieren",
  "command.o.restart": "OmniSharp neu starten",
  "command.razor.reportIssue": "Razor-Problem melden",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitObjectCreation": "Hinweise für die implizite Objekterstellung anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitVariableTypes": "Hinweise für Variablen mit abgeleiteten Typen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForIndexerParameters": "Hinweise für Indexer anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForLambdaParameterTypes": "Hinweise für Lambda-Parametertypen anzeigen",
  "configuration.csharp.inlayHints.enableInlayHintsForTypes": "Inlinetyphinweise anzeigen",
  "configuration.dotnet.autoInsert.enableAutoInsert": "Aktivieren Sie das automatische Einfügen von Dokumentationskommentaren.",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope": "Ausführen der Hintergrundcodeanalyse für: (Zuvor \"omnisharp.enableRoslynAnalyzers\")",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope": "Compilerfehler und -warnungen anzeigen für:",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.fullSolution": "Gesamte Projektmappe",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.none": "Keine",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.openFiles": "Geöffnete Dokumente",
  "configuration.dotnet.codeLens.enableReferencesCodeLens": "Gibt an, ob die Verweise auf CodeLens angezeigt werden sollen. (Zuvor \"csharp.referencesCodeLens.enabled\")",
  "configuration.dotnet.codeLens.enableTestsCodeLens": "Gibt an, ob der CodeLens-Test zum Ausführen und Debuggen angezeigt werden soll. (Zuvor \"csharp.testsCodeLens.enabled\")",
  "configuration.dotnet.completion.provideRegexCompletions": "Reguläre Ausdrücke in der Vervollständigungsliste anzeigen.",
  "configuration.dotnet.completion.showCompletionItemsFromUnimportedNamespaces": "Ermöglicht die Anzeige nicht importierter Typen und nicht importierter Erweiterungsmethoden in Vervollständigungslisten. Wenn ein Commit ausgeführt wird, wird die entsprechende using-Direktive am Anfang der aktuellen Datei hinzugefügt. (Zuvor \"omnisharp.enableImportCompletion\")",
  "configuration.dotnet.completion.showNameCompletionSuggestions": "Führen Sie die automatische Vervollständigung des Objektnamens für die Elemente aus, die Sie kürzlich ausgewählt haben.",
  "configuration.dotnet.completion.triggerCompletionInArgumentLists": "Vervollständigungsliste in Argumentlisten automatisch anzeigen",
  "configuration.dotnet.defaultSolution.description": "Der Pfad der Standardlösung, die im Arbeitsbereich geöffnet werden soll, oder auf \"deaktivieren\" festlegen, um sie zu überspringen. (Zuvor \"omnisharp.defaultLaunchSolution\")",
  "configuration.dotnet.diagnostics.reportInformationAsHint": "Aktivieren Sie diese Einstellung, um visuelle Ablenkungen in Ihrem Editor zu reduzieren. Informationsprobleme werden als Hinweise gemeldet und sind nur sichtbar, wenn das Popupfenster für Codeaktionen geöffnet ist.",
  "configuration.dotnet.enableXamlTools": "Aktiviert XAML-Tools bei Verwendung des C#-Dev Kit",
  "configuration.dotnet.formatting.organizeImportsOnFormat": "Gibt an, ob „using“-Anweisungen während der Dokumentformatierung gruppiert und sortiert werden sollen. (Zuvor „omnisharp.organizeImportsOnFormat“)",
  "configuration.dotnet.highlighting.highlightRelatedJsonComponents": "Zugehörige JSON-Komponenten unter dem Cursor markieren.",
  "configuration.dotnet.highlighting.highlightRelatedRegexComponents": "Zugehörige Komponenten regulärer Ausdrücke unter dem Cursor markieren.",
  "configuration.dotnet.inlayHints.enableInlayHintsForLiteralParameters": "Hinweise für Literale anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": "Hinweise für new-Ausdrücke anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForOtherParameters": "Hinweise für alles andere anzeigen",
  "configuration.dotnet.inlayHints.enableInlayHintsForParameters": "Hinweise zu Inlineparameternamen anzeigen",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatDifferOnlyBySuffix": "Hinweise unterdrücken, wenn sich Parameternamen nur durch das Suffix unterscheiden",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchArgumentName": "Hinweise unterdrücken, wenn das Argument mit dem Namen des Parameters übereinstimmt",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchMethodIntent": "Hinweise unterdrücken, wenn der Parametername mit der Methodenabsicht übereinstimmt",
  "configuration.dotnet.navigation.navigateToDecompiledSources": "Aktivieren der Navigation zu dekompilierten Quellen.",
  "configuration.dotnet.navigation.navigateToSourceLinkAndEmbeddedSources": "Navigation zu Quelllinks und eingebetteten Quellen aktivieren",
  "configuration.dotnet.preferCSharpExtension": "Erzwingt, dass Projekte nur mit der C#-Erweiterung geladen werden.  Dies kann nützlich sein, wenn Legacy-Projekttypen verwendet werden, die vom C# Dev Kit nicht unterstützt werden. (Erfordert erneutes Laden des Fensters)",
  "configuration.dotnet.projects.binaryLogPath": "Legt einen Pfad fest, in den binäre MSBuild-Protokolle beim Laden von Projekten geschrieben werden, um die Diagnose von Ladefehlern zu unterstützen.",
  "configuration.dotnet.projects.enableAutomaticRestore": "Aktiviert die automatische NuGet-Wiederherstellung, wenn die Erweiterung erkennt, dass Ressourcen fehlen.",
  "configuration.dotnet.projects.enableFileBasedPrograms": "Aktiviert die Vorschau für die Erfahrung „dateibasierte Programme“ (dotnet run app.cs).",
  "configuration.dotnet.quickInfo.showRemarksInQuickInfo": "Beschreibungsinformationen beim Anzeigen des Symbols anzeigen.",
  "configuration.dotnet.server.componentPaths": "Ermöglicht das Überschreiben des Ordnerpfads für eingebaute Komponenten des Sprachservers (z. B. Überschreiben des Pfads .roslynDevKit im Erweiterungsverzeichnis, um lokal erstellte Komponenten zu verwenden)",
  "configuration.dotnet.server.componentPaths.roslynCopilot": "Überschreibt den Ordnerpfad für die .roslynCopilot-Komponente des Sprachservers",
  "configuration.dotnet.server.componentPaths.roslynDevKit": "Überschreibt den Ordnerpfad für die Komponente .roslynDevKit des Sprachservers",
  "configuration.dotnet.server.componentPaths.xamlTools": "Überschreibt den Ordnerpfad für die Komponente .xamlTools des Sprachservers",
  "configuration.dotnet.server.crashDumpPath": "Legt einen Ordnerpfad fest, in den Absturzabbilder geschrieben werden, wenn der Sprachserver abstürzt.  Muss vom Benutzer beschreibbar sein.",
  "configuration.dotnet.server.extensionPaths": "Außerkraftsetzung für Pfad zu Sprachserver --extension-Argumenten",
  "configuration.dotnet.server.path": "Gibt den absoluten Pfad zur ausführbaren Serverdatei (LSP oder O#) an. Wenn sie leer gelassen wird, wird die an die C#-Erweiterung angeheftete Version verwendet. (Zuvor \"omnisharp.path\")",
  "configuration.dotnet.server.startTimeout": "Gibt ein Timeout (in ms) an, mit dem der Client erfolgreich gestartet und eine Verbindung mit dem Sprachserver hergestellt werden kann.",
  "configuration.dotnet.server.suppressLspErrorToasts": "Unterdrückt, dass Fehler-Popups angezeigt werden, wenn auf dem Server ein wiederherstellbarer Fehler auftritt.",
  "configuration.dotnet.server.suppressMiscellaneousFilesToasts": "Hiermit wird die Anzeige von Popupwarnungen unterdrückt, wenn sich das aktive Dokument außerhalb des geöffneten Arbeitsbereichs befindet.",
  "configuration.dotnet.server.useServerGC": "Konfigurieren Sie den Sprachserver für die Verwendung der GC des .NET-Servers.  Die GC auf dem Server bietet im Allgemeinen eine bessere Leistung bei einem höheren Arbeitsspeicherverbrauch.",
  "configuration.dotnet.server.waitForDebugger": "Übergibt das Flag \"--debug\" beim Starten des Servers, damit ein Debugger angefügt werden kann. (Zuvor \"omnisharp.waitForDebugger\")",
  "configuration.dotnet.symbolSearch.searchReferenceAssemblies": "Symbole in Verweisassemblys suchen. Dies wirkt sich auf Features aus, die eine Symbolsuche erfordern, z. B. Importe hinzufügen.",
  "configuration.dotnet.typeMembers.memberInsertionLocation": "Die Einfügeposition von Eigenschaften, Ereignissen und Methoden beim Implementieren der Schnittstelle oder abstrakten Klasse.",
  "configuration.dotnet.typeMembers.memberInsertionLocation.atTheEnd": "Platzieren Sie sie am Ende.",
  "configuration.dotnet.typeMembers.memberInsertionLocation.withOtherMembersOfTheSameKind": "Platzieren Sie sie mit anderen Mitgliedern derselben Art.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior": "Generierungsverhalten von Eigenschaften beim Implementieren einer Schnittstelle oder einer abstrakten Klasse.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior.preferAutoProperties": "Automatische Eigenschaften bevorzugen.",
  "configuration.dotnet.typeMembers.propertyGenerationBehavior.preferThrowingProperties": "Ausgelöste Eigenschaften bevorzugen.",
  "configuration.dotnet.unitTestDebuggingOptions": "Optionen, die mit dem Debugger beim Starten des Komponententestdebuggings verwendet werden können. (Zuvor \"csharp.unitTestDebuggingOptions\")",
  "configuration.dotnet.unitTests.runSettingsPath": "Pfad zur „.runsettings“-Datei, die beim Ausführen von Komponententests verwendet werden soll. (Vorher `omnisharp.testRunSettings`)",
  "configuration.omnisharp.autoStart": "Gibt an, ob der OmniSharp-Server automatisch gestartet wird. Bei „false“ kann OmniSharp mit dem Befehl „OmniSharp neu starten“ gestartet werden.",
  "configuration.omnisharp.csharp.format.enable": "Standard-C#-Formatierer aktivieren/deaktivieren (Neustart erforderlich).",
  "configuration.omnisharp.csharp.maxProjectFileCountForDiagnosticAnalysis": "Gibt die maximale Anzahl von Dateien an, für die Diagnosen für den gesamten Arbeitsbereich gemeldet werden. Wenn dieser Grenzwert überschritten wird, wird die Diagnose nur für aktuell geöffnete Dateien angezeigt. Geben Sie 0 oder weniger an, um das Limit vollständig zu deaktivieren.",
  "configuration.omnisharp.csharp.referencesCodeLens.filteredSymbols": "Array benutzerdefinierter Symbolnamen, für die CodeLens deaktiviert werden soll.",
  "configuration.omnisharp.csharp.semanticHighlighting.enabled": "Semantische Hervorhebung für C#-Dateien aktivieren/deaktivieren (Razor-Dateien werden derzeit nicht unterstützt). Der Standardwert ist FALSE. Schließen Sie geöffnete Dateien, damit die Änderungen wirksam werden.",
  "configuration.omnisharp.csharp.showOmnisharpLogOnError": "Zeigt das OmniSharp-Protokoll im Ausgabebereich an, wenn OmniSharp einen Fehler meldet.",
  "configuration.omnisharp.csharp.suppressBuildAssetsNotification": "Das Benachrichtigungsfenster, um fehlende Ressourcen zum Erstellen oder Debuggen der Anwendung hinzuzufügen, wird unterdrückt.",
  "configuration.omnisharp.csharp.suppressDotnetInstallWarning": "Die Warnung, dass sich das .NET Core SDK nicht im Pfad befindet, wird unterdrückt.",
  "configuration.omnisharp.csharp.suppressDotnetRestoreNotification": "Das Benachrichtigungsfenster, um „dotnet restore“ auszuführen, wenn Abhängigkeiten nicht aufgelöst werden können, wird unterdrückt.",
  "configuration.omnisharp.csharp.suppressHiddenDiagnostics": "„Ausgeblendete“ Diagnosen (z. B. nicht benötigte Using-Anweisungen) werden unterdrückt und nicht im Editor oder im Problembereich angezeigt.",
  "configuration.omnisharp.csharp.suppressProjectJsonWarning": "Die Warnung, dass „project.json“ kein unterstütztes Projektformat mehr für .NET Core-Anwendungen ist, wird unterdrückt",
  "configuration.omnisharp.disableMSBuildDiagnosticWarning": "Gibt an, ob Benachrichtigungen angezeigt werden sollen, wenn in OmniSharp Warnungen oder Fehler beim Laden eines Projekts auftreten. Beachten Sie, dass diese Warnungen/Fehler immer in das OmniSharp-Protokoll ausgegeben werden.",
  "configuration.omnisharp.dotNetCliPaths": "Pfade zu einem lokalen Download der .NET-CLI, der zum Ausführen von Benutzercode verwendet werden soll.",
  "configuration.omnisharp.dotnet.server.useOmnisharp": "Wechselt bei Aktivierung zur Verwendung des Omnisharp-Servers für Sprachfeatures (Neustart erforderlich). Diese Option wird bei installiertem C#-Entwicklerkit nicht berücksichtigt.",
  "configuration.omnisharp.dotnetPath": "Gibt den Pfad zu einem dotnet-Installationsverzeichnis an, das anstelle des Standardsystems verwendet werden soll. Dies wirkt sich nur auf die dotnet-Installation aus, die zum Hosten des OmniSharp-Servers selbst verwendet werden soll. Beispiel: \"/home/username/mycustomdotnetdirectory\".",
  "configuration.omnisharp.enableAsyncCompletion": "Aktiviert die Unterstützung für das asynchrone Auflösen von Vervollständigungsbearbeitungen. Dies kann die Zeit bis zum Anzeigen der Vervollständigungsliste verkürzen, insbesondere bei Vervollständigungslisten für Überschreiben und partielle Methoden. Der Nachteil sind geringfügige Verzögerungen nach dem Einfügen eines Vervollständigungselements. Die meisten Vervollständigungselemente haben bei diesem Feature keine merklichen Auswirkungen, aber die Eingabe unmittelbar nach dem Einfügen einer Vervollständigung für eine Überschreibung oder partielle Methode kann unvorhersehbare Ergebnisse haben.",
  "configuration.omnisharp.enableDecompilationSupport": "Aktiviert die Unterstützung für das Dekompilieren externer Verweise, anstatt Metadaten anzuzeigen.",
  "configuration.omnisharp.enableEditorConfigSupport": "Aktiviert die Unterstützung für das Lesen von Einstellungen für Codestil, Namenskonventionen und Analyseeinstellungen aus „.editorconfig“.",
  "configuration.omnisharp.enableLspDriver": "Aktiviert die Unterstützung für das auf experimentellen Sprachprotokollen basierende Modul (erfordert erneutes Laden, um Bindungen ordnungsgemäß einzurichten)",
  "configuration.omnisharp.enableMsBuildLoadProjectsOnDemand": "Bei „true“ lädt das MSBuild-Projektsystem nur Projekte für Dateien, die im Editor geöffnet wurden. Diese Einstellung ist für große C#-Codebases nützlich und ermöglicht eine schnellere Initialisierung von Codenavigationsfunktionen nur für Projekte, die für Code relevant sind, der bearbeitet wird. Mit dieser Einstellung lädt OmniSharp möglicherweise weniger Projekte und zeigt daher ggf. unvollständige Verweislisten für Symbole an.",
  "configuration.omnisharp.loggingLevel": "Gibt den Grad der Protokollierungsausgabe vom OmniSharp-Server an.",
  "configuration.omnisharp.maxFindSymbolsItems": "Die maximale Anzahl von Elementen, die beim Vorgang „Zu Symbol im Arbeitsbereich wechseln“ angezeigt werden kann. Der Grenzwert wird nur angewendet, wenn hier eine positive Zahl angegeben wird.",
  "configuration.omnisharp.maxProjectResults": "Die maximale Anzahl von Projekten, die in der Dropdownliste „Projekt auswählen“ angezeigt werden sollen (maximal 250).",
  "configuration.omnisharp.minFindSymbolsFilterLength": "Die Mindestanzahl von Zeichen, die eingegeben werden muss, bevor der Vorgang „Zu Symbol im Arbeitsbereich wechseln“ Ergebnisse anzeigt.",
  "configuration.omnisharp.monoPath": "Gibt den Pfad zu einer Mono-Installation an, die statt der standardmäßigen Systeminstallation verwendet werden soll, wenn „useModernNet“ auf FALSE festgelegt ist. Beispiel: „/Library/Frameworks/Mono.framework/Versions/Current“",
  "configuration.omnisharp.projectFilesExcludePattern": "Das von OmniSharp verwendete Ausschlussmuster zum Auffinden aller Projektdateien.",
  "configuration.omnisharp.projectLoadTimeout": "Die Zeit, die Visual Studio Code auf den Start des OmniSharp-Servers wartet. Die Zeit wird in Sekunden ausgedrückt.",
  "configuration.omnisharp.razor.completion.commitElementsWithSpace": "Gibt an, ob ein Commit für das Taghilfsprogramm und Komponentenelemente mit einem Leerzeichen ausgeführt werden soll.",
  "configuration.omnisharp.razor.devmode": "Erzwingt die Ausführung der Erweiterung in einem Modus, der die lokale Razor.VSCode-Entwicklung ermöglicht.",
  "configuration.omnisharp.razor.format.codeBlockBraceOnNextLine": "Erzwingt, dass die öffnende geschweifte Klammer nach einer @code- oder @functions-Anweisung in der folgenden Zeile steht.",
  "configuration.omnisharp.razor.format.enable": "Razor-Standardformatierer aktivieren/deaktivieren.",
  "configuration.omnisharp.razor.plugin.path": "Überschreibt den Pfad zur Razor-Plug-In-DLL.",
  "configuration.omnisharp.sdkIncludePrereleases": "Gibt an, ob Vorschauversionen des .NET SDK einbezogen werden sollen, wenn bestimmt wird, welche Version zum Laden des Projekts verwendet werden soll. Gilt, wenn „useModernNet“ auf TRUE festgelegt ist.",
  "configuration.omnisharp.sdkPath": "Gibt den Pfad zu einer .NET SDK-Installation an, die für das Laden von Projekten anstelle der höchsten installierten Version verwendet werden soll. Gilt, wenn „useModernNet“ auf TRUE festgelegt ist. Beispiel: /home/username/dotnet/sdks/6.0.300.",
  "configuration.omnisharp.sdkVersion": "Gibt die Version des .NET SDK an, die für das Laden von Projekten anstelle der höchsten installierten Version verwendet werden soll. Gilt, wenn „useModernNet“ auf TRUE festgelegt ist. Beispiel: 6.0.300.",
  "configuration.omnisharp.useEditorFormattingSettings": "Gibt an, ob OmniSharp VS Code-Editoreinstellungen für C#-Codeformatierung verwenden soll (Verwendung von Registerkarten, Einzugsgröße).",
  "configuration.omnisharp.useModernNet.description": "Verwenden Sie den OmniSharp-Build für .NET 6. Diese Version unterstützt _keine_ .NET Framework-Projekte, die nicht im SDK-Stil vorliegen, einschließlich Unity. Framework-Projekte im SDK-Stil, .NET Core- und .NET 5+-Projekte sollten erhebliche Leistungsverbesserungen aufweisen.",
  "configuration.omnisharp.useModernNet.title": ".NET 6-Build von OmniSharp verwenden",
  "configuration.razor.languageServer.cohostingEnabled": "Razor-Cohosting aktivieren.",
  "configuration.razor.languageServer.debug": "Gibt an, ob beim Starten des Sprachservers auf die Debuganfügung gewartet werden soll.",
  "configuration.razor.languageServer.directory": "Überschreibt den Pfad zum Razor-Sprachserver-Verzeichnis.",
  "configuration.razor.languageServer.suppressLspErrorToasts": "Unterdrückt, dass Fehler-Popups angezeigt werden, wenn auf dem Server ein wiederherstellbarer Fehler auftritt.",
  "configuration.razor.server.trace": "Gibt den Protokolliergrad an, der für den Razor-Server verwendet werden soll.",
  "debuggers.coreclr.configurationSnippets.description.attach": "Fügen Sie den .NET-Debugger (coreclr) an einen laufenden Prozess an. Dies kann auch mit dem Befehl \"An einen .NET 5+- oder .NET Core-Prozess anfügen\" erfolgen.",
  "debuggers.coreclr.configurationSnippets.description.blazor-hosted": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem Blazor WebAssembly-Debugger (blazorwasm) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel kann jedoch verwendet werden, um Vollzugriff auf alle Startoptionen zu erhalten. Dieser Codeschnipsel ist für gehostete Blazor-Projekte vorgesehen. Dabei handelt es sich um ein Projekt, das im Back-End über eine ASP.NET Core-App zum Verarbeiten der Dateien verfügt.",
  "debuggers.coreclr.configurationSnippets.description.blazor-standalone": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem Blazor WebAssembly-Debugger (blazorwasm) zu starten. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel kann jedoch verwendet werden, um Vollzugriff auf alle Startoptionen zu erhalten. Dieser Codeschnipsel ist für eigenständige Blazor-Projekte vorgesehen. Dabei handelt es sich um ein Projekt, das im Back-End über keine ASP.NET Core-App zum Verarbeiten der Dateien verfügt.",
  "debuggers.coreclr.configurationSnippets.description.console-local": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem .NET-Debugger (coreclr) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel ist nützlich, wenn das Projekt außerhalb dieser VS Code-Instanz erstellt wurde, wenn Sie Ihren .NET-Code in einer benutzerdefinierten ausführbaren Datei (z. B. in einer bestimmten Version von \"dotnet.exe\"/\"dotnet\") hosten möchten oder wenn der .NET-Code von einer nativen Anwendung gehostet wird. Dieser Codeschnipsel ist für Konsolenanwendungen vorgesehen.",
  "debuggers.coreclr.configurationSnippets.description.remote": "Dieser Codeschnipsel zeigt, wie Sie ein Remotedebuggen von .NET Code **ohne** die Remotefunktion von VS Code durchführen. Dies sollte in Fällen verwendet werden, in denen Sie Ihr Projekt lokal erstellen, aber auf einem anderen Computer ausführen möchten.",
  "debuggers.coreclr.configurationSnippets.description.web-local": "Dieser Codeschnipsel wird verwendet, um einen neuen Prozess unter dem .NET-Debugger (coreclr) zu starten. Dabei wird der Pfad zu der ausführbaren Datei angegeben, die gestartet werden soll. In den meisten Fällen ist der Codeschnipsel \".NET: C#-Projekt starten\" die bessere Wahl. Dieser Codeschnipsel ist nützlich, wenn das Projekt außerhalb dieser VS Code-Instanz erstellt wurde, wenn Sie Ihren .NET-Code in einer benutzerdefinierten ausführbaren Datei (z. B. in einer bestimmten Version von \"dotnet.exe\"/\"dotnet\") hosten möchten oder wenn der .NET-Code von einer nativen Anwendung gehostet wird. Dieser Codeschnipsel ist für Webanwendungen (ASP.NET Core) geeignet.",
  "debuggers.coreclr.configurationSnippets.label.attach-local": ".NET: An einen .NET-Prozess anfügen",
  "debuggers.coreclr.configurationSnippets.label.attach-remote": ".NET: Remotedebuggen – An .NET-Prozess anfügen",
  "debuggers.coreclr.configurationSnippets.label.blazor-hosted": ".NET: Webassembly – Gehostetes Blazor-Projekt starten",
  "debuggers.coreclr.configurationSnippets.label.blazor-standalone": ".NET: Webassembly – Eigenständiges Blazor-Projekt starten",
  "debuggers.coreclr.configurationSnippets.label.console-local": ".NET: Ausführbare Datei starten (Konsole)",
  "debuggers.coreclr.configurationSnippets.label.console-remote": ".NET: Remotedebuggen – Ausführbare Datei starten (Konsole)",
  "debuggers.coreclr.configurationSnippets.label.web-local": ".NET: Ausführbare Datei starten (Web)",
  "debuggers.dotnet.configurationSnippets.description": "Dieser Codeschnipsel konfiguriert VS Code für das Debuggen eines C#-Projekts. Debugoptionen (zum Beispiel Argumente für die ausführbare Datei) können über die Datei '<project-directory>/Properties/launchSettings.json' konfiguriert werden.",
  "debuggers.dotnet.configurationSnippets.label": ".NET: C#-Projekt starten",
  "debuggers.dotnet.launch.launchConfigurationId.description": "Die zu verwendende Startkonfigurations-ID. Eine leere Zeichenfolge verwendet die aktuelle aktive Konfiguration.",
  "debuggers.dotnet.launch.projectPath.description": "Pfad zur CSPROJ-Datei.",
  "generateOptionsSchema.args.0.description": "Befehlszeilenargumente, die an das Programm übergeben werden.",
  "generateOptionsSchema.args.1.description": "An das Programm übergebene Zeichenfolgenversion von Befehlszeilenargumenten.",
  "generateOptionsSchema.checkForDevCert.description": "Wenn Sie ein Webprojekt unter Windows oder macOS starten und dies aktiviert ist, überprüft der Debugger, ob der Computer über ein selbstsigniertes HTTPS-Zertifikat verfügt, das zum Entwickeln von Webservern verwendet wird, die auf HTTPS-Endpunkten ausgeführt werden. Wenn nicht angegeben, wird standardmäßig \"true\" verwendet, wenn \"serverReadyAction\" festgelegt ist. Mit dieser Option werden keine Linux-, VS Code-Remote- und VS Code-Webbenutzeroberflächenszenarien ausgeführt. Wenn das HTTPS-Zertifikat nicht gefunden wird oder nicht vertrauenswürdig ist, wird der Benutzer aufgefordert, es zu installieren bzw. ihm zu vertrauen.",
  "generateOptionsSchema.console.externalTerminal.enumDescription": "Der Zielprozess wird in einem eigenen externen Terminal ausgeführt. Wenn Sie diesen Modus verwenden, müssen Sie den Fokus zwischen Visual Studio Code und dem externen Terminalfenster wechseln.",
  "generateOptionsSchema.console.integratedTerminal.enumDescription": "Der Zielprozess wird im integrierten Terminal VS Code ausgeführt.",
  "generateOptionsSchema.console.internalConsole.enumDescription": "Die Konsoleneingabe (stdin) und die Ausgabe (stdout/stderr) des Zielprozesses werden über die VS Code Debugging-Konsole weitergeleitet.",
  "generateOptionsSchema.console.markdownDescription": "Gibt an, in welcher Konsole das Zielprogramm gestartet werden soll. Weitere Informationen finden Sie unter „https://aka.ms/VSCode-CS-LaunchJson-Console“.",
  "generateOptionsSchema.console.settingsDescription": "**Hinweis:** _Diese Option wird nur für Konsolenprojekte verwendet, die mit der Debugkonfiguration vom Typ „dotnet“ gestartet wurden_.\r\n\r\nGibt an, in welcher Konsole das Zielprogramm gestartet werden soll. Weitere Informationen finden Sie unter „https://aka.ms/VSCode-CS-LaunchJson-Console“.",
  "generateOptionsSchema.cwd.description": "Pfad zum Arbeitsverzeichnis des Programms, das gedebuggt wird. Der Standardwert ist der aktuelle Arbeitsbereich.",
  "generateOptionsSchema.debugServer.description": "Nur für die Entwicklung von Debugerweiterungen: Wenn ein Port angegeben ist, versucht der VS-Code, eine Verbindung mit einem Debugadapter herzustellen, der im Servermodus ausgeführt wird.",
  "generateOptionsSchema.enableStepFiltering.markdownDescription": "Kennzeichnung zum Aktivieren des Schrittweisen Ausführens von Eigenschaften und Operatoren. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.env.description": "Umgebungsvariablen, die an das Programm übergeben werden.",
  "generateOptionsSchema.envFile.markdownDescription": "Umgebungsvariablen, die von einer Datei an das Programm übergeben werden. Beispiel: \"${workspaceFolder}/.env\"",
  "generateOptionsSchema.expressionEvaluationOptions.allowFastEvaluate.description": "Bei \"true\" (Standardzustand) versucht der Debugger eine schnellere Auswertung, indem er die Ausführung einfacher Eigenschaften und Methoden simuliert.",
  "generateOptionsSchema.expressionEvaluationOptions.allowImplicitFuncEval.description": "Bei WAHR (Standardzustand) ruft der Debugger automatisch „Abruf“-Methoden der Eigenschaft und andere implizite Funktionsaufrufe auf.",
  "generateOptionsSchema.expressionEvaluationOptions.allowToString.markdownDescription": "Bei WAHR (Standardzustand) ruft der Debugger automatisch „ToString“ auf, um Objekte zu formatieren. Diese Option hat keine Auswirkung, wenn „allowImplicitFuncEval“ auf FALSCH festgelegt ist.",
  "generateOptionsSchema.expressionEvaluationOptions.description": "Optionen zum Steuern, wie der Debugger Ausdrücke in Datentipps, in den Abschnitten „Überwachen“ und „Variablen“ der Debugansicht oder im Debugging-Konsole auswertet.",
  "generateOptionsSchema.expressionEvaluationOptions.showRawValues.description": "Bei WAHR zeigt der Debugger die rohe Struktur von Objekten in Variablenfenstern an.",
  "generateOptionsSchema.externalConsole.markdownDescription": "Das Attribut \"externalConsole\" ist veraltet. Verwenden Sie stattdessen \"console\". Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.justMyCode.markdownDescription": "Wenn diese Option aktiviert ist (Standardeinstellung), wird der Debugger nur angezeigt und in den Benutzercode (\"Mein Code\") eingeschritten. Dabei werden Systemcode und anderer Code ignoriert, der optimiert ist oder über keine Debugsymbole verfügt. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson-JustMyCode)",
  "generateOptionsSchema.launchBrowser.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Dies wird nur verwendet, wenn das plattformspezifische Element (\"osx\", \"linux\" oder \"windows\") keinen Wert für \"args\" angibt. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.description": "Beschreibt Optionen zum Starten eines Webbrowsers als Teil des Starts.",
  "generateOptionsSchema.launchBrowser.enabled.description": "Gibt an, ob das Starten des Webbrowsers aktiviert ist. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.launchBrowser.linux.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.linux.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.linux.description": "Linux-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"xdg-open\" gestartet.",
  "generateOptionsSchema.launchBrowser.osx.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.osx.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.osx.description": "OSX-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"open\" gestartet.",
  "generateOptionsSchema.launchBrowser.windows.args.description": "Die Argumente, die an den Befehl übergeben werden sollen, um den Browser zu öffnen. Verwenden Sie ${auto-detect-url}, um automatisch die Adresse zu verwenden, an der der Server lauscht.",
  "generateOptionsSchema.launchBrowser.windows.command.description": "Die ausführbare Datei, die den Webbrowser startet.",
  "generateOptionsSchema.launchBrowser.windows.description": "Windows-spezifische Optionen für Webstartkonfiguration. Der Browser wird standardmäßig mit \"cmd /c start\" gestartet.",
  "generateOptionsSchema.launchSettingsFilePath.markdownDescription": "Der Pfad zu einer Datei \"launchSettings.json\". Wenn dies nicht festgelegt ist, sucht der Debugger in \"{cwd}/Properties/launchSettings.json\".",
  "generateOptionsSchema.launchSettingsProfile.description": "Gibt bei Angabe den Namen des Profils in \"launchSettings.json\" an, das verwendet werden soll. Dies wird ignoriert, wenn launchSettings.json nicht gefunden wird. \"launchSettings.json\" wird aus dem angegebenen Pfad gelesen. Dabei muss es sich um die Eigenschaft \"launchSettingsFilePath\" oder um {cwd}/Properties/launchSettings.json handeln, wenn dies nicht festgelegt ist. Wenn dieser Wert auf NULL oder eine leere Zeichenfolge festgelegt ist, wird launchSettings.json ignoriert. Wenn dieser Wert nicht angegeben ist, wird das erste Projekt-Profil verwendet.",
  "generateOptionsSchema.logging.browserStdOut.markdownDescription": "Kennzeichnung, um zu bestimmen, ob stdout-Text vom Start des Webbrowsers im Ausgabefenster protokolliert werden soll. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.consoleUsageMessage.description": "Steuert, ob eine Nachricht protokolliert wird, wenn der Zielprozess eine Console.Read*-API aufruft und stdin an die Konsole umgeleitet wird.",
  "generateOptionsSchema.logging.description": "Kennzeichnungen, um zu bestimmen, welche Nachrichtentypen im Ausgabefenster protokolliert werden sollen.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.all.enumDescription": "Hiermit werden alle Debugger-API-Aufrufe ausgegeben. Diese Option ist sehr ausführlich.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.error.enumDescription": "Hiermit werden Fehler aus Debugger-API-Aufrufen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.markdownDescription": "Steuert, ob API-Aufrufe an \"Microsoft.VisualStudio.Debugger.Engine/vsdebugeng.h\" im Ausgabefenster ausgegeben werden sollen. Diese Option ist standardmäßig auf \"none\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.none.enumDescription": "Ablaufverfolgung für API-Aufrufe deaktivieren",
  "generateOptionsSchema.logging.diagnosticsLog.debugRuntimeEventTracing.markdownDescription": "Flag, mit dem festgelegt wird, ob die ausführliche Ablaufverfolgung für Ereignisse aktiviert werden soll, die von der zugrunde liegenden Runtime ausgelöst werden. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.description": "Einstellungen, mit denen festgelegt wird, welche Meldungen aus dem Diagnoseprotokoll des Debuggers im Ausgabefenster ausgegeben werden. Dieses Protokoll dient zur Unterstützung bei der Behandlung von Problemen mit dem Debugger.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.error.enumDescription": "Hiermit werden Diagnosemeldungen auf Fehlerebene ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.important.enumDescription": "Hiermit werden wichtige Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.markdownDescription": "Steuert, welche Meldungen vom Dispatcher des Debuggers im Ausgabefenster ausgegeben werden. Sofern nicht angegeben, wird standardmäßig \"none\" verwendet – es sei denn, eine der ausführlichen Protokolleinstellungen ist aktiviert (\"debugEngineAPITracing\", \"debugRuntimeEventTracing\", \"expressionEvaluationTracing\" oder \"startDebuggingTracing\"). In diesem Fall wird der Standardwert in \"normal\" geändert.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.none.enumDescription": "Hiermit werden keine zusätzlichen Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.normal.enumDescription": "Hiermit werden alle nicht ausführlichen Diagnosemeldungen ausgegeben.",
  "generateOptionsSchema.logging.diagnosticsLog.expressionEvaluationTracing.markdownDescription": "Flag, mit dem festgelegt wird, ob die ausführliche Ablaufverfolgung für die Ausdrucksauswertung aktiviert werden soll. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.protocolMessages.markdownDescription": "Flag, mit dem festgelegt wird, ob die zwischen dem C#-Debugger und der Benutzeroberfläche ausgetauschten DAP-Protokollnachrichten im Ausgabefenster protokolliert werden sollen. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.diagnosticsLog.startDebuggingTracing.markdownDescription": "Flag zur Festlegung, ob die ausführliche Ablaufverfolgung beim Starten des Debuggens aktiviert werden soll. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.elapsedTiming.markdownDescription": "Bei einer Festlegung auf \"true\" umfasst die Nachrichtenprotokollierung die Eigenschaften \"adapterElapsedTime\" und \"engineElapsedTime\", um die Zeitspanne in Mikrosekunden anzugeben, die für eine Anforderung benötigt wurde. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.logging.engineLogging.deprecationMessage": "Die Einstellung \"logging.engineLogging\" wurde zugunsten von \"logging.diagnosticsLog.protocolMessages\" als veraltet eingestuft.",
  "generateOptionsSchema.logging.exceptions.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Ausnahmemeldungen im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.moduleLoad.markdownDescription": "Kennzeichnung, um zu bestimmen, ob Modulladeereignisse im Ausgabefenster protokolliert werden sollen. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.processExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn der Zielprozess beendet oder das Debuggen beendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.programOutput.markdownDescription": "Kennzeichnung, um zu bestimmen, ob die Programmausgabe im Ausgabefenster protokolliert werden soll, wenn keine externe Konsole verwendet wird. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.logging.threadExit.markdownDescription": "Steuert, ob eine Nachricht protokolliert wird, wenn ein Thread im Zielprozess beendet wird. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.pipeTransport.debuggerPath.description": "Der vollständige Pfad zum Debugger auf dem Zielcomputer.",
  "generateOptionsSchema.pipeTransport.description": "Wenn vorhanden, weist dies den Debugger an, eine Verbindung mit einem Remotecomputer mithilfe einer anderen ausführbaren Datei als Pipe herzustellen, die die Standardeingabe/-ausgabe zwischen VS Code und der ausführbaren .NET Core-Debugger-Back-End-Datei (vsdbg) weiterleitet.",
  "generateOptionsSchema.pipeTransport.linux.description": "Linux-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.linux.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.linux.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.linux.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.linux.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.osx.description": "OSX-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.osx.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.osx.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.osx.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.osx.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.pipeTransport.windows.description": "Windows-spezifische Optionen für Pipestartkonfiguration",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.0.description": "Befehlszeilenargumente, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.1.description": "Zeichenfolgenversion von Befehlszeilenargumenten, die an das Pipeprogramm übergeben werden. Token ${debuggerCommand} in pipeArgs wird durch den vollständigen Debuggerbefehl ersetzt. Dieses Token kann inline mit anderen Argumenten angegeben werden. Wenn ${debuggerCommand} in keinem Argument verwendet wird, wird stattdessen der vollständige Debuggerbefehl am Ende der Argumentliste hinzugefügt.",
  "generateOptionsSchema.pipeTransport.windows.pipeCwd.description": "Der vollqualifizierte Pfad zum Arbeitsverzeichnis für das Pipeprogramm.",
  "generateOptionsSchema.pipeTransport.windows.pipeEnv.description": "Umgebungsvariablen, die an das Pipeprogramm übergeben werden.",
  "generateOptionsSchema.pipeTransport.windows.pipeProgram.description": "Der vollqualifizierte auszuführende Pipebefehl.",
  "generateOptionsSchema.pipeTransport.windows.quoteArgs.description": "Sollten Argumente, die Zeichen enthalten, die in Anführungszeichen gesetzt werden müssen (Beispiel: Leerzeichen), in Anführungszeichen gesetzt werden? Der Standardwert ist \"true\". Bei Festlegung auf \"false\" wird der Debuggerbefehl nicht mehr automatisch in Anführungszeichen gesetzt.",
  "generateOptionsSchema.processId.0.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processId.1.markdownDescription": "Die Prozess-ID, an die angefügt werden soll. Verwenden Sie \"\", um eine Liste der ausgeführten Prozesse abzurufen, an die angefügt werden soll. Wenn \"processId\" verwendet wird, sollte \"processName\" nicht verwendet werden.",
  "generateOptionsSchema.processName.markdownDescription": "Der Prozessname, an den angefügt werden soll. Wenn dies verwendet wird, sollte \"processId\" nicht verwendet werden.",
  "generateOptionsSchema.program.markdownDescription": "Pfad zur Anwendungs-DLL oder ausführbaren .NET Core-Hostdatei, die gestartet werden soll.\r\nDiese Eigenschaft hat normalerweise folgendes Format: \"${workspaceFolder}/bin/Debug/(target-framework)/(project-name.dll)\"\r\n\r\nBeispiel: \"`${workspaceFolder}/bin/Debug/netcoreapp1.1/MyProject.dll`\r\n\r\nWo:\r\n\"(target-framework)\" ist das Framework, für das das debuggte Projekt erstellt wird. Dies wird normalerweise in der Projektdatei als TargetFramework-Eigenschaft gefunden.\r\n\r\n\"(project-name.dll)\" ist der Name der Buildausgabe-DLL des debuggten Projekts. Dies ist normalerweise identisch mit dem Projektdateinamen, aber mit der Erweiterung \".dll\".",
  "generateOptionsSchema.requireExactSource.markdownDescription": "Kennzeichnung, dass der aktuelle Quellcode dem PDB entsprechen muss. Diese Option wird standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceFileMap.markdownDescription": "Ordnet Buildzeitpfade lokalen Quellspeicherorten zu. Alle Instanzen des Buildzeitpfads werden durch den lokalen Quellpfad ersetzt.\r\n\r\nBeispiel:\r\n\r\n'{\"<build-path>\":\"<local-source-path>\"}'",
  "generateOptionsSchema.sourceLinkOptions.additionalItems.enabled.markdownDescription": "Ist Source Link für diese URL aktiviert? Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"true\" festgelegt.",
  "generateOptionsSchema.sourceLinkOptions.markdownDescription": "Optionen zum Steuern der Verbindung von Source Link mit Webservern. [Weitere Informationen](https://aka.ms/VSCode-DotNet-SourceLink)",
  "generateOptionsSchema.stopAtEntry.markdownDescription": "Bei \"true\" sollte der Debugger am Einstiegspunkt des Ziels beendet werden. Diese Option ist standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.suppressJITOptimizations.markdownDescription": "Bei \"true\" fordert der Debugger den Just-In-Time-Compiler auf, Code mit deaktivierten Optimierungen zu generieren, wenn ein optimiertes Modul (DLL- kompiliert in der Releasekonfiguration) im Zielprozess geladen wird. [Weitere Informationen](https://aka.ms/VSCode-CS-LaunchJson-SuppressJITOptimizations)",
  "generateOptionsSchema.symbolOptions.cachePath.description": "Verzeichnis, in dem von Symbolservern heruntergeladene Symbole zwischengespeichert werden sollen. Wenn nicht angegeben, wird der Debugger unter Windows standardmäßig auf %TEMP%\\SymbolCache festgelegt, und unter Linux und macOS wird der Debugger standardmäßig auf ~/.dotnet/symbolcache festgelegt.",
  "generateOptionsSchema.symbolOptions.description": "Optionen zum Steuern, wie Symbole (PDB-Dateien) gefunden und geladen werden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.description": "Stellt Optionen bereit, um zu steuern, für welche Module (DLL-Dateien) der Debugger versuchen soll, Symbole (PDB-Dateien) zu laden.",
  "generateOptionsSchema.symbolOptions.moduleFilter.excludedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadAllButExcluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsNextToModules.description": "Wenn „true“, wird der Debugger für ein beliebiges Modul, das sich NICHT im Array „includedModules“ befindet, weiterhin neben dem Modul selbst und der ausführbaren Datei, die gestartet wird, überprüfen. Die Pfade in der Symbolsuchliste werden jedoch nicht überprüft. Diese Option ist standardmäßig auf „true“ eingestellt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsOnDemand.description": "TRUE gibt an, dass der Debugger für alle Module, die NICHT im includedModules-Array enthalten sind, versucht, Symbole herunterzuladen, wenn erkannt wird, dass Symbole erforderlich sind, z. B. beim Versuch, in das Modul einzutreten. Diese Option ist standardmäßig auf \"true\" festgelegt.\r\n\r\nDiese Eigenschaft wird ignoriert, es sei denn, \"mode\" ist auf \"loadOnlyIncluded\" festgelegt.",
  "generateOptionsSchema.symbolOptions.moduleFilter.includedModules.description": "Ein Array von Modulen, für das der Debugger keine Symbole laden soll. Platzhalter (Beispiel: MyCompany. *. dll) werden unterstützt.\r\n\r\nDiese Eigenschaft wird ignoriert, wenn „Modus“ nicht auf „loadOnlyIncluded“ festgelegt ist.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.description": "Steuert, in welchem der beiden grundlegenden Betriebsmodi der Modulfilter ausgeführt wird.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadAllButExcluded.enumDescription": "Laden Sie Symbole für alle Module, es sei denn, das Modul befindet sich im Array „excludedModules“.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadOnlyIncluded.enumDescription": "Versuchen Sie nicht, Symbole für IRGENDEIN Modul zu laden, es sei denn, es befindet sich im Array „includedModules“, oder es wird über die Einstellung „includeSymbolsNextToModules“ hinzugefügt.",
  "generateOptionsSchema.symbolOptions.searchMicrosoftSymbolServer.description": "Wenn „true“, wird der Microsoft-Symbolserver (https​://msdl.microsoft.com​/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn nicht angegeben, wird diese Option standardmäßig auf „false“ eingestellt.",
  "generateOptionsSchema.symbolOptions.searchNuGetOrgSymbolServer.description": "Bei \"true\" wird der NuGet.org-Symbolserver (https​://symbols.nuget.org​/download/symbols) dem Symbolsuchpfad hinzugefügt. Wenn keine Angabe erfolgt, wird diese Option standardmäßig auf \"false\" festgelegt.",
  "generateOptionsSchema.symbolOptions.searchPaths.description": "Array von Symbolserver-URLs (example: http​://MyExampleSymbolServer) oder Verzeichnisse (example: /build/symbols), um nach PDB-Dateien zu suchen. Diese Verzeichnisse werden zusätzlich zu den Standardspeicherorten durchsucht – neben dem Modul und dem Pfad, in dem die PDB-Datei ursprünglich abgelegt wurde.",
  "generateOptionsSchema.targetArchitecture.markdownDescription": "[Nur beim lokalen macOS-Debuggen unterstützt]\r\n\r\nDie Architektur des Debuggens. Dies wird automatisch erkannt, es sei denn, dieser Parameter ist festgelegt. Zulässige Werte sind \"x86_64\" oder \"arm64\".",
  "generateOptionsSchema.targetOutputLogPath.description": "Bei Festlegung wird Text, den die Zielanwendung in \"stdout\" und \"stderr\" (z. B. Console.WriteLine) schreibt, in der angegebenen Datei gespeichert. Diese Option wird ignoriert, wenn die Konsole auf einen anderen Wert als internalConsole festgelegt ist. Beispiel: \"${workspaceFolder}/out.txt\"",
  "generateOptionsSchema.type.markdownDescription": "Geben Sie den Typ des zu debuggenden Codes ein. Dies kann `coreclr` für das .NET Core-Debugging oder `clr` für Desktop .NET Framework sein. `clr` funktioniert nur für Windows, da das Desktopframework nur Windows ist.",
  "viewsWelcome.debug.contents": "[C#-Objekte für Build und Debuggen generieren](command:dotnet.generateAssets)\r\n\r\nWeitere Informationen zu launch.json finden Sie unter [Konfigurieren von launch.json für das C#-Debuggen](https://aka.ms/VSCode-CS-LaunchJson)."
}